---
title: 'Uncertaintly Principal and Software Engineering'
date: Mon, 28 Feb 2005 23:06:14 +0000
draft: false
tags: ['Uncategorized']
---

[Uncertainty Principal](http://scienceworld.wolfram.com/physics/UncertaintyPrinciple.html) is a principle of quantum mechanics postulated by [Nobel laureate](http://nobelprize.org/physics/laureates/1932/) [Werner Heisenberg](http://en.wikipedia.org/wiki/Werner_Heisenberg) in the 1920s which states that it is not possible to determine both the position and the momentum of a particle at the same instant. The reason he argued, was that the act of "observing" the particle changes its behavior with respect to what is being measured. He was one of the first scientists to bring in probability into the predictable science of physics.

Prior to Heisenberg's theory most physicists (including [Albert Einstein](http://www.hawking.org.uk/lectures/dice.html)) believed that one day physics and computing would be powerful enough that given an input we would be able to predict the future **exactly** because we would know how each and every element in the universe would react and therefore be able to model time and space with infinite precision. But with the advent of Heisenberg's principal and modern quantum physics (which is almost always a function of probability) physics is no where near predictable.

But what does all this have to do with software engineering? Professor Hadar Ziv and Debra Richardson from [UCI](http://www.uci.edu/) [published a paper](/2005/02/upsw.pdf) arguing that software engineering is inherently uncertain. The reason they argued was the three sources of uncertainty within all softwares:

1.  Uncertainty in the problem domain: The first source of uncertainty is the problem domain. The authors argue that since most softwares models "real world" and real world is full of uncertainties. The software that models the real world therefore will inevitably contain those uncertainties.
2.  The second source of uncertainty was that in addition to problem domain uncertainties, softwares themselves introduce uncertainties. The authors use concurrent softwares as an example to argue their point.
3.  Their third argument is that softwares are tools that depend greatly on human participation; and human behavior is another area where great amount of uncertainties can be introduced (read my entry on [Can UIs produce bugs](/blog/can-uis-produce-bugs/2005/02/))

[Uncertainty Principle in Software Engineering](/2005/02/upsw.pdf) is a great publication for anyone interested in the topic of testing, validation or software engineering in general. You can download a copy [from here](/2005/02/upsw.pdf) or [visit their site](http://jeffsutherland.org/papers/zivchaos.html) where the download is also available.