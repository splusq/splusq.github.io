<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.120.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Reverse a linked list recursively &#183; Salman Quazi</title>
<meta name=description content><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/poole.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/syntax.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><style type=text/css>.sidebar-about h1{font-size:1.95rem;font-weight:400}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-K4WVH5P91F"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K4WVH5P91F")</script></head><body class=theme-base-08><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://www.salmanq.com/><h1>Salman Quazi</h1></a><p class=lead>Director of Engineering for Microsoft Azure OpenAI in Mountain View, CA.</p></div><nav><ul class=sidebar-nav><li><a href=https://www.salmanq.com/>Home</a></li><li><a href=/blog/>Blog</a></li><li><a href=https://github.com/splusq/>Github</a></li><li><a href=https://www.linkedin.com/in/salmanquazi/>LinkedIn</a></li><li><a href=https://www.twitter.com/splusq>Twitter</a></li></ul></nav><p>Opinions are my own.</p></div></aside><main class="content container"><div class=post><h1>Reverse a linked list recursively</h1><time datetime=2007-05-23T23:26:12Z class=post-date>Wed, May 23, 2007</time><p>A question came up the other day while I was helping a friend of mine about recursively reversing a <a href=http://en.wikipedia.org/wiki/Linked_list>singly linked list</a>. The moment I heard about it I came up with a solution, but turns out the solution requires the function to accept the following signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>List<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseList</span>(List <span style=color:#f92672>*</span>l);
</span></span></code></pre></div><p>This actually poses a problem because there&rsquo;s no way to keep track of the head, or maintain any back pointers which could&rsquo;ve been done if the function accepted a second parameter. Anyway, so I thought about it and initially started with some of the base cases:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>List<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseList</span>(List <span style=color:#f92672>*</span>l) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> l;
</span></span><span style=display:flex><span>	<span style=color:#f92672>???</span> 
</span></span></code></pre></div><p>Now comes the tricky part. What do you do in the general case? If you think of two nodes, you realize that you have to change the next->next pointer to the current node, change the next pointer of the current node to the previous node (null if it&rsquo;s the last node) and you are done! The idea is the same with nodes more than two, the only thing you have to be careful about is when you make the recursive call. One way to grasp the idea is to realize that you have to force the stack to get as deep as possible (get to the next to last node) and set it&rsquo;s next node to null and then work yourself backwards. With that thought, I came up with this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span> List<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseList</span>(List <span style=color:#f92672>*</span>l) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> l;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reverseList</span>(l<span style=color:#f92672>-&gt;</span>next); 
</span></span></code></pre></div><p>Finally, I needed to reorder the next links as the stack returns back:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span> List<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseList</span>(List <span style=color:#f92672>*</span>l) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> l;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reverseList</span>(l<span style=color:#f92672>-&gt;</span>next);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	l<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> l;
</span></span><span style=display:flex><span>	l<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> null;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> l;
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>There it was that was the solution. Notice I ignore the return statement in the recursive call. This perhaps isn&rsquo;t very intuitive but since I am looking ahead one I don&rsquo;t necessarily need a pointer to the last element, only until n-1.</p></div><h2>Comments</h2><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></main></body></html>