<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Reverse a linked list recursively | Salman Quazi</title><meta name=keywords content="Uncategorized"><meta name=description content="A question came up the other day while I was helping a friend of mine about recursively reversing a singly linked list. The moment I heard about it I came up with a solution, but turns out the solution requires the function to accept the following signature:
List* reverseList(List *l); This actually poses a problem because there&rsquo;s no way to keep track of the head, or maintain any back pointers which could&rsquo;ve been done if the function accepted a second parameter."><meta name=author content><link rel=canonical href=https://www.salmanq.com/blog/reverse-a-linked-list-recursively/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.salmanq.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.salmanq.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.salmanq.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.salmanq.com/apple-touch-icon.png><link rel=mask-icon href=https://www.salmanq.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-38742121-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Reverse a linked list recursively"><meta property="og:description" content="A question came up the other day while I was helping a friend of mine about recursively reversing a singly linked list. The moment I heard about it I came up with a solution, but turns out the solution requires the function to accept the following signature:
List* reverseList(List *l); This actually poses a problem because there&rsquo;s no way to keep track of the head, or maintain any back pointers which could&rsquo;ve been done if the function accepted a second parameter."><meta property="og:type" content="article"><meta property="og:url" content="https://www.salmanq.com/blog/reverse-a-linked-list-recursively/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2007-05-23T23:26:12+00:00"><meta property="article:modified_time" content="2007-05-23T23:26:12+00:00"><meta property="og:site_name" content="Salman Quazi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reverse a linked list recursively"><meta name=twitter:description content="A question came up the other day while I was helping a friend of mine about recursively reversing a singly linked list. The moment I heard about it I came up with a solution, but turns out the solution requires the function to accept the following signature:
List* reverseList(List *l); This actually poses a problem because there&rsquo;s no way to keep track of the head, or maintain any back pointers which could&rsquo;ve been done if the function accepted a second parameter."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://www.salmanq.com/blog/"},{"@type":"ListItem","position":2,"name":"Reverse a linked list recursively","item":"https://www.salmanq.com/blog/reverse-a-linked-list-recursively/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Reverse a linked list recursively","name":"Reverse a linked list recursively","description":"A question came up the other day while I was helping a friend of mine about recursively reversing a singly linked list. The moment I heard about it I came up with a solution, but turns out the solution requires the function to accept the following signature:\nList* reverseList(List *l); This actually poses a problem because there\u0026rsquo;s no way to keep track of the head, or maintain any back pointers which could\u0026rsquo;ve been done if the function accepted a second parameter.","keywords":["Uncategorized"],"articleBody":"A question came up the other day while I was helping a friend of mine about recursively reversing a singly linked list. The moment I heard about it I came up with a solution, but turns out the solution requires the function to accept the following signature:\nList* reverseList(List *l); This actually poses a problem because there’s no way to keep track of the head, or maintain any back pointers which could’ve been done if the function accepted a second parameter. Anyway, so I thought about it and initially started with some of the base cases:\nList* reverseList(List *l) { if(l==NULL) return NULL; if(l-\u003enext==NULL) return l; ??? Now comes the tricky part. What do you do in the general case? If you think of two nodes, you realize that you have to change the next-\u003enext pointer to the current node, change the next pointer of the current node to the previous node (null if it’s the last node) and you are done! The idea is the same with nodes more than two, the only thing you have to be careful about is when you make the recursive call. One way to grasp the idea is to realize that you have to force the stack to get as deep as possible (get to the next to last node) and set it’s next node to null and then work yourself backwards. With that thought, I came up with this:\nList* reverseList(List *l) { if(l==NULL) return NULL; if(l-\u003enext==NULL) return l; reverseList(l-\u003enext); Finally, I needed to reorder the next links as the stack returns back:\nList* reverseList(List *l) { if(l==NULL) return NULL; if(l-\u003enext==NULL) return l; reverseList(l-\u003enext); l-\u003enext-\u003enext = l; l-\u003enext = null; return l; } There it was that was the solution. Notice I ignore the return statement in the recursive call. This perhaps isn’t very intuitive but since I am looking ahead one I don’t necessarily need a pointer to the last element, only until n-1.\n","wordCount":"323","inLanguage":"en","datePublished":"2007-05-23T23:26:12Z","dateModified":"2007-05-23T23:26:12Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.salmanq.com/blog/reverse-a-linked-list-recursively/"},"publisher":{"@type":"Organization","name":"Salman Quazi","logo":{"@type":"ImageObject","url":"https://www.salmanq.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.salmanq.com/ accesskey=h title="Salman Quazi (Alt + H)">Salman Quazi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.salmanq.com/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://github.com/splusq/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.linkedin.com/in/salmanquazi/ title=LinkedIn><span>LinkedIn</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.twitter.com/splusq title=Twitter><span>Twitter</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Reverse a linked list recursively</h1><div class=post-meta><span title='2007-05-23 23:26:12 +0000 UTC'>May 23, 2007</span>&nbsp;·&nbsp;2 min</div></header><div class=post-content><p>A question came up the other day while I was helping a friend of mine about recursively reversing a <a href=http://en.wikipedia.org/wiki/Linked_list>singly linked list</a>. The moment I heard about it I came up with a solution, but turns out the solution requires the function to accept the following signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>List<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseList</span>(List <span style=color:#f92672>*</span>l);
</span></span></code></pre></div><p>This actually poses a problem because there&rsquo;s no way to keep track of the head, or maintain any back pointers which could&rsquo;ve been done if the function accepted a second parameter. Anyway, so I thought about it and initially started with some of the base cases:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>List<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseList</span>(List <span style=color:#f92672>*</span>l) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> l;
</span></span><span style=display:flex><span>	<span style=color:#f92672>???</span> 
</span></span></code></pre></div><p>Now comes the tricky part. What do you do in the general case? If you think of two nodes, you realize that you have to change the next->next pointer to the current node, change the next pointer of the current node to the previous node (null if it&rsquo;s the last node) and you are done! The idea is the same with nodes more than two, the only thing you have to be careful about is when you make the recursive call. One way to grasp the idea is to realize that you have to force the stack to get as deep as possible (get to the next to last node) and set it&rsquo;s next node to null and then work yourself backwards. With that thought, I came up with this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span> List<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseList</span>(List <span style=color:#f92672>*</span>l) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> l;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reverseList</span>(l<span style=color:#f92672>-&gt;</span>next); 
</span></span></code></pre></div><p>Finally, I needed to reorder the next links as the stack returns back:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span> List<span style=color:#f92672>*</span> <span style=color:#a6e22e>reverseList</span>(List <span style=color:#f92672>*</span>l) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span>(l<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>==</span>NULL) <span style=color:#66d9ef>return</span> l;
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reverseList</span>(l<span style=color:#f92672>-&gt;</span>next);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	l<span style=color:#f92672>-&gt;</span>next<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> l;
</span></span><span style=display:flex><span>	l<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> null;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> l;
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>There it was that was the solution. Notice I ignore the return statement in the recursive call. This perhaps isn&rsquo;t very intuitive but since I am looking ahead one I don&rsquo;t necessarily need a pointer to the last element, only until n-1.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.salmanq.com/tags/uncategorized/>Uncategorized</a></li></ul><nav class=paginav><a class=prev href=https://www.salmanq.com/blog/script-task-readingreturning-data/><span class=title>« Prev</span><br><span>Script Task reading/returning data</span></a>
<a class=next href=https://www.salmanq.com/blog/legacy-code/><span class=title>Next »</span><br><span>Legacy code</span></a></nav></footer><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.salmanq.com/>Salman Quazi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>