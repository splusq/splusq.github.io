<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.134.2"><meta name=viewport content="width=device-width,initial-scale=1"><title>How do you test your software? &#183; Salman Quazi</title>
<meta name=description content><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/poole.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/syntax.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><style type=text/css>.sidebar-about h1{font-size:1.95rem;font-weight:400}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-K4WVH5P91F"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K4WVH5P91F")</script></head><body class=theme-base-08><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://www.salmanq.com/><h1>Salman Quazi</h1></a><p class=lead>Director of Engineering for Microsoft Azure OpenAI in Mountain View, CA.</p></div><nav><ul class=sidebar-nav><li><a href=https://www.salmanq.com/>Home</a></li><li><a href=/blog/>Blog</a></li><li><a href=https://github.com/splusq/>Github</a></li><li><a href=https://www.linkedin.com/in/salmanquazi/>LinkedIn</a></li><li><a href=https://www.twitter.com/splusq>Twitter</a></li></ul></nav><p>Opinions are my own.</p></div></aside><main class="content container"><div class=post><h1>How do you test your software?</h1><time datetime=2013-03-01T15:09:40Z class=post-date>Fri, Mar 1, 2013</time><p>There seems to be two types of developers out there. One that believes in integration tests, and the other that believes in both unit and integration tests. Integration tests are tests that execute everything as if they were real &ldquo;transactions&rdquo; only to verify the expected results. For instance, if you were building a web application that managed a list of employees and their supervisors. Your integration test would probably add an employee to the database (actually add it), and then read it back from that database, and so on (from a test database of course). There&rsquo;s nothing wrong this, and in fact I would argue these types of tests are great. You need to write integration tests that exercise your entire stack. Without it would be like exercising without doing cardio. What differentiates a unit test from other types of tests is that you test a &ldquo;unit&rdquo; of your application alone. Now what that unit is, is up to you. But the point is you take a <em>part</em> of your application and test it in <em>isolation</em>. That part could be a class, it could be multiple sets of classes, but not your application as a whole - otherwise it would become an integration test. Seems like we have a conundrum here. We just argued that a integration test, tests everything, end-to-end, the entire stack &ndash; and a unit test, tests a part of the application in isolation. Isn&rsquo;t integration test then a superset of unit tests? And there is where the confusion lies. <strong>So why write unit tests?</strong> While it is true that unit tests can often uncover bugs in the code, in reality unit tests actually help discover a far bigger problem; and that is design of your system. Unit tests can discover design issues if left unaddressed could severely impact your velocity to adapt to change. I would argue that if you can write proper tests for your system with good code coverage, then you have a well designed, cohesive system. Now unit testing alone is no silver bullet to design verification, but it&rsquo;s pretty close. Let&rsquo;s look at a really simple example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PaymentManager</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> Logger logger;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> PaymentManager() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.logger = <span style=color:#66d9ef>new</span> InstrumentationLogger();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Credit(Transaction transaction) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// credit </span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.logger.Log(<span style=color:#e6db74>&#34;Credit Amount &#34;</span>, transaction.Amount);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>Now this looks like a perfectly valid code. Would pass all sorts of integration tests, but there&rsquo;s a glaring problem here. The problem has to do with the Logger. At this point it should be obvious to anyone reading this that where the Logger logs this message is irrelevant to the PaymentManager. It could care less. The logger could decide to log to a database, to the file system, to a message queue, to the cloud. Who knows. Doesn&rsquo;t matter. However, the very fact that we have the initialization of the logger is in the constructor - we actually coupled the PaymentManager to how the logger functions, weather we like it or not. Think for a second why that is. If the Logger was to log to a database, then it&rsquo;s very likely in the constructor of the InstrumentationLogger we would be initializing a connection to a database preparing ourselves to log messages - which means we would need a connection string, and all sorts of other stuff available in the &ldquo;context&rdquo; of the PaymentManager. Now think for a second what happens when you want to write a test for this class PaymentManager. It will indirectly need all the database settings, a &ldquo;test&rdquo; database just to be able to test this class. Which doesn&rsquo;t make any sense, because what you are trying to test is the PaymentManager not the Logger. But the way this class is written there&rsquo;s really not much you can do. This is where a unit test helps you. When you struggle to write tests for something that generally means you have a big design problem. So let&rsquo;s see how we can fix this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PaymentManager</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> ILogger logger;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> PaymentManager(ILogger logger) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.logger = logger;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Credit(Transaction transaction) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// credit </span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.logger.Log(<span style=color:#e6db74>&#34;Credit Amount &#34;</span>, transaction.Amount);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>So we made two subtle changes. First we changed Logger to a more abstract interface ILogger, and secondly instead of constructing the logger we made it <a href=http://en.wikipedia.org/wiki/Inversion_of_control>someone elses&rsquo; responsibility</a>. Now when we are testing this we can easily pass a fake object that implements ILogger and we can test our <code>PaymentManager</code>. Now that <code>PaymentManager</code> depends on a more abstract concept a <code>ILogger</code> - we can replace it with anything that implements that interface. We have <a href=http://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming)>externalized the details of our dependency</a>. This leads to patterns like <a href=http://en.wikipedia.org/wiki/Inversion_of_control>Inversion of Control</a>, and <a href=http://en.wikipedia.org/wiki/Dependency_injection>dependency injection</a>. I will cover these topics in-depth as well. So I hope with this very simple it was clear to you that unit test, not only identifies bugs in your code, it can also help identify design issues.</p></div><h2>Comments</h2><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></main></body></html>