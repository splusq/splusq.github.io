<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How do you test your software? | Salman Quazi</title><meta name=keywords content="Uncategorized"><meta name=description content="There seems to be two types of developers out there. One that believes in integration tests, and the other that believes in both unit and integration tests. Integration tests are tests that execute everything as if they were real &ldquo;transactions&rdquo; only to verify the expected results. For instance, if you were building a web application that managed a list of employees and their supervisors. Your integration test would probably add an employee to the database (actually add it), and then read it back from that database, and so on (from a test database of course)."><meta name=author content><link rel=canonical href=https://www.salmanq.com/blog/how-do-you-test-your-software/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.salmanq.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.salmanq.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.salmanq.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.salmanq.com/apple-touch-icon.png><link rel=mask-icon href=https://www.salmanq.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-38742121-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="How do you test your software?"><meta property="og:description" content="There seems to be two types of developers out there. One that believes in integration tests, and the other that believes in both unit and integration tests. Integration tests are tests that execute everything as if they were real &ldquo;transactions&rdquo; only to verify the expected results. For instance, if you were building a web application that managed a list of employees and their supervisors. Your integration test would probably add an employee to the database (actually add it), and then read it back from that database, and so on (from a test database of course)."><meta property="og:type" content="article"><meta property="og:url" content="https://www.salmanq.com/blog/how-do-you-test-your-software/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2013-03-01T15:09:40+00:00"><meta property="article:modified_time" content="2013-03-01T15:09:40+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="How do you test your software?"><meta name=twitter:description content="There seems to be two types of developers out there. One that believes in integration tests, and the other that believes in both unit and integration tests. Integration tests are tests that execute everything as if they were real &ldquo;transactions&rdquo; only to verify the expected results. For instance, if you were building a web application that managed a list of employees and their supervisors. Your integration test would probably add an employee to the database (actually add it), and then read it back from that database, and so on (from a test database of course)."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://www.salmanq.com/blog/"},{"@type":"ListItem","position":2,"name":"How do you test your software?","item":"https://www.salmanq.com/blog/how-do-you-test-your-software/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How do you test your software?","name":"How do you test your software?","description":"There seems to be two types of developers out there. One that believes in integration tests, and the other that believes in both unit and integration tests. Integration tests are tests that execute everything as if they were real \u0026ldquo;transactions\u0026rdquo; only to verify the expected results. For instance, if you were building a web application that managed a list of employees and their supervisors. Your integration test would probably add an employee to the database (actually add it), and then read it back from that database, and so on (from a test database of course).","keywords":["Uncategorized"],"articleBody":"There seems to be two types of developers out there. One that believes in integration tests, and the other that believes in both unit and integration tests. Integration tests are tests that execute everything as if they were real “transactions” only to verify the expected results. For instance, if you were building a web application that managed a list of employees and their supervisors. Your integration test would probably add an employee to the database (actually add it), and then read it back from that database, and so on (from a test database of course). There’s nothing wrong this, and in fact I would argue these types of tests are great. You need to write integration tests that exercise your entire stack. Without it would be like exercising without doing cardio. What differentiates a unit test from other types of tests is that you test a “unit” of your application alone. Now what that unit is, is up to you. But the point is you take a part of your application and test it in isolation. That part could be a class, it could be multiple sets of classes, but not your application as a whole - otherwise it would become an integration test. Seems like we have a conundrum here. We just argued that a integration test, tests everything, end-to-end, the entire stack – and a unit test, tests a part of the application in isolation. Isn’t integration test then a superset of unit tests? And there is where the confusion lies. So why write unit tests? While it is true that unit tests can often uncover bugs in the code, in reality unit tests actually help discover a far bigger problem; and that is design of your system. Unit tests can discover design issues if left unaddressed could severely impact your velocity to adapt to change. I would argue that if you can write proper tests for your system with good code coverage, then you have a well designed, cohesive system. Now unit testing alone is no silver bullet to design verification, but it’s pretty close. Let’s look at a really simple example:\npublic class PaymentManager { private Logger logger; public PaymentManager() { this.logger = new InstrumentationLogger(); } public void Credit(Transaction transaction) { // credit this.logger.Log(\"Credit Amount \", transaction.Amount); } } Now this looks like a perfectly valid code. Would pass all sorts of integration tests, but there’s a glaring problem here. The problem has to do with the Logger. At this point it should be obvious to anyone reading this that where the Logger logs this message is irrelevant to the PaymentManager. It could care less. The logger could decide to log to a database, to the file system, to a message queue, to the cloud. Who knows. Doesn’t matter. However, the very fact that we have the initialization of the logger is in the constructor - we actually coupled the PaymentManager to how the logger functions, weather we like it or not. Think for a second why that is. If the Logger was to log to a database, then it’s very likely in the constructor of the InstrumentationLogger we would be initializing a connection to a database preparing ourselves to log messages - which means we would need a connection string, and all sorts of other stuff available in the “context” of the PaymentManager. Now think for a second what happens when you want to write a test for this class PaymentManager. It will indirectly need all the database settings, a “test” database just to be able to test this class. Which doesn’t make any sense, because what you are trying to test is the PaymentManager not the Logger. But the way this class is written there’s really not much you can do. This is where a unit test helps you. When you struggle to write tests for something that generally means you have a big design problem. So let’s see how we can fix this:\npublic class PaymentManager { private ILogger logger; public PaymentManager(ILogger logger) { this.logger = logger; } public void Credit(Transaction transaction) { // credit this.logger.Log(\"Credit Amount \", transaction.Amount); } } So we made two subtle changes. First we changed Logger to a more abstract interface ILogger, and secondly instead of constructing the logger we made it someone elses’ responsibility. Now when we are testing this we can easily pass a fake object that implements ILogger and we can test our PaymentManager. Now that PaymentManager depends on a more abstract concept a ILogger - we can replace it with anything that implements that interface. We have externalized the details of our dependency. This leads to patterns like Inversion of Control, and dependency injection. I will cover these topics in-depth as well. So I hope with this very simple it was clear to you that unit test, not only identifies bugs in your code, it can also help identify design issues.\n","wordCount":"817","inLanguage":"en","datePublished":"2013-03-01T15:09:40Z","dateModified":"2013-03-01T15:09:40Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.salmanq.com/blog/how-do-you-test-your-software/"},"publisher":{"@type":"Organization","name":"Salman Quazi","logo":{"@type":"ImageObject","url":"https://www.salmanq.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.salmanq.com/ accesskey=h title="Salman Quazi (Alt + H)">Salman Quazi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.salmanq.com/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://github.com/splusq/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.linkedin.com/in/salmanquazi/ title=LinkedIn><span>LinkedIn</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.twitter.com/splusq title=Twitter><span>Twitter</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><div class=post><h1>How do you test your software?</h1><time datetime=2013-03-01T15:09:40Z class=post-date>Fri, Mar 1, 2013</time><p>There seems to be two types of developers out there. One that believes in integration tests, and the other that believes in both unit and integration tests. Integration tests are tests that execute everything as if they were real &ldquo;transactions&rdquo; only to verify the expected results. For instance, if you were building a web application that managed a list of employees and their supervisors. Your integration test would probably add an employee to the database (actually add it), and then read it back from that database, and so on (from a test database of course). There&rsquo;s nothing wrong this, and in fact I would argue these types of tests are great. You need to write integration tests that exercise your entire stack. Without it would be like exercising without doing cardio. What differentiates a unit test from other types of tests is that you test a &ldquo;unit&rdquo; of your application alone. Now what that unit is, is up to you. But the point is you take a <em>part</em> of your application and test it in <em>isolation</em>. That part could be a class, it could be multiple sets of classes, but not your application as a whole - otherwise it would become an integration test. Seems like we have a conundrum here. We just argued that a integration test, tests everything, end-to-end, the entire stack &ndash; and a unit test, tests a part of the application in isolation. Isn&rsquo;t integration test then a superset of unit tests? And there is where the confusion lies. <strong>So why write unit tests?</strong> While it is true that unit tests can often uncover bugs in the code, in reality unit tests actually help discover a far bigger problem; and that is design of your system. Unit tests can discover design issues if left unaddressed could severely impact your velocity to adapt to change. I would argue that if you can write proper tests for your system with good code coverage, then you have a well designed, cohesive system. Now unit testing alone is no silver bullet to design verification, but it&rsquo;s pretty close. Let&rsquo;s look at a really simple example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PaymentManager</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> Logger logger;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> PaymentManager() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.logger = <span style=color:#66d9ef>new</span> InstrumentationLogger();
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Credit(Transaction transaction) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// credit </span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.logger.Log(<span style=color:#e6db74>&#34;Credit Amount &#34;</span>, transaction.Amount);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>Now this looks like a perfectly valid code. Would pass all sorts of integration tests, but there&rsquo;s a glaring problem here. The problem has to do with the Logger. At this point it should be obvious to anyone reading this that where the Logger logs this message is irrelevant to the PaymentManager. It could care less. The logger could decide to log to a database, to the file system, to a message queue, to the cloud. Who knows. Doesn&rsquo;t matter. However, the very fact that we have the initialization of the logger is in the constructor - we actually coupled the PaymentManager to how the logger functions, weather we like it or not. Think for a second why that is. If the Logger was to log to a database, then it&rsquo;s very likely in the constructor of the InstrumentationLogger we would be initializing a connection to a database preparing ourselves to log messages - which means we would need a connection string, and all sorts of other stuff available in the &ldquo;context&rdquo; of the PaymentManager. Now think for a second what happens when you want to write a test for this class PaymentManager. It will indirectly need all the database settings, a &ldquo;test&rdquo; database just to be able to test this class. Which doesn&rsquo;t make any sense, because what you are trying to test is the PaymentManager not the Logger. But the way this class is written there&rsquo;s really not much you can do. This is where a unit test helps you. When you struggle to write tests for something that generally means you have a big design problem. So let&rsquo;s see how we can fix this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PaymentManager</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>private</span> ILogger logger;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> PaymentManager(ILogger logger) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.logger = logger;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Credit(Transaction transaction) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// credit </span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>this</span>.logger.Log(<span style=color:#e6db74>&#34;Credit Amount &#34;</span>, transaction.Amount);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>So we made two subtle changes. First we changed Logger to a more abstract interface ILogger, and secondly instead of constructing the logger we made it <a href=http://en.wikipedia.org/wiki/Inversion_of_control>someone elses&rsquo; responsibility</a>. Now when we are testing this we can easily pass a fake object that implements ILogger and we can test our <code>PaymentManager</code>. Now that <code>PaymentManager</code> depends on a more abstract concept a <code>ILogger</code> - we can replace it with anything that implements that interface. We have <a href=http://en.wikipedia.org/wiki/Abstraction_principle_(computer_programming)>externalized the details of our dependency</a>. This leads to patterns like <a href=http://en.wikipedia.org/wiki/Inversion_of_control>Inversion of Control</a>, and <a href=http://en.wikipedia.org/wiki/Dependency_injection>dependency injection</a>. I will cover these topics in-depth as well. So I hope with this very simple it was clear to you that unit test, not only identifies bugs in your code, it can also help identify design issues.</p></div><br><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-dark crossorigin=anonymous async></script></main><footer class=footer><span>&copy; 2023 <a href=https://www.salmanq.com/>Salman Quazi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>