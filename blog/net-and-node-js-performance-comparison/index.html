<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>.NET and Node.JS - Performance Comparison (Updated) | Salman Quazi</title><meta name=keywords content="Uncategorized"><meta name=description content="Update (3/31/2013 - 11:41 PM PST):
This article has been updated! As most readers have commented the node.js async package is not asynchronous, which is what the original article was based on. I made an assumption I should not have. I have since rerun the tests taking this into account, as well as some of the changes recommended by Guillaume Lecomte. I have decided to update this existing post so that there&rsquo;s no confusion in the future with the data."><meta name=author content><link rel=canonical href=https://www.salmanq.com/blog/net-and-node-js-performance-comparison/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.salmanq.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.salmanq.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.salmanq.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.salmanq.com/apple-touch-icon.png><link rel=mask-icon href=https://www.salmanq.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-38742121-1","auto"),ga("send","pageview"))</script><meta property="og:title" content=".NET and Node.JS - Performance Comparison (Updated)"><meta property="og:description" content="Update (3/31/2013 - 11:41 PM PST):
This article has been updated! As most readers have commented the node.js async package is not asynchronous, which is what the original article was based on. I made an assumption I should not have. I have since rerun the tests taking this into account, as well as some of the changes recommended by Guillaume Lecomte. I have decided to update this existing post so that there&rsquo;s no confusion in the future with the data."><meta property="og:type" content="article"><meta property="og:url" content="https://www.salmanq.com/blog/net-and-node-js-performance-comparison/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2013-03-26T08:57:39+00:00"><meta property="article:modified_time" content="2013-03-26T08:57:39+00:00"><meta property="og:site_name" content="Salman Quazi"><meta name=twitter:card content="summary"><meta name=twitter:title content=".NET and Node.JS - Performance Comparison (Updated)"><meta name=twitter:description content="Update (3/31/2013 - 11:41 PM PST):
This article has been updated! As most readers have commented the node.js async package is not asynchronous, which is what the original article was based on. I made an assumption I should not have. I have since rerun the tests taking this into account, as well as some of the changes recommended by Guillaume Lecomte. I have decided to update this existing post so that there&rsquo;s no confusion in the future with the data."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://www.salmanq.com/blog/"},{"@type":"ListItem","position":2,"name":".NET and Node.JS - Performance Comparison (Updated)","item":"https://www.salmanq.com/blog/net-and-node-js-performance-comparison/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":".NET and Node.JS - Performance Comparison (Updated)","name":".NET and Node.JS - Performance Comparison (Updated)","description":"Update (3/31/2013 - 11:41 PM PST):\nThis article has been updated! As most readers have commented the node.js async package is not asynchronous, which is what the original article was based on. I made an assumption I should not have. I have since rerun the tests taking this into account, as well as some of the changes recommended by Guillaume Lecomte. I have decided to update this existing post so that there\u0026rsquo;s no confusion in the future with the data.","keywords":["Uncategorized"],"articleBody":"Update (3/31/2013 - 11:41 PM PST):\nThis article has been updated! As most readers have commented the node.js async package is not asynchronous, which is what the original article was based on. I made an assumption I should not have. I have since rerun the tests taking this into account, as well as some of the changes recommended by Guillaume Lecomte. I have decided to update this existing post so that there’s no confusion in the future with the data. Thank you everyone for all the comments, posts and keeping me sane.\nUpdate (3/29/2013 - 3:43 PM PST):\nThere’s been a lot of valid comments around the use of the async NPM package for node.js which are valid. I will take them into account and re-run these tests. If you talk to any silicon valley startup today chances are you will hear about node.js. One of the key reasons most argue is that node.js is fast, scalable because of forced non-blocking IO, and it’s efficient use of a single threaded model. I personally love JavaScript, so being able to use JavaScript on the server side seemed like a key gain. But I was never really sold into the notion that node.js is supremely fast because there aren’t any context switches and thread synchronizations. We all know these practices should be avoided at all costs in any multi-threaded program, but to give it all away seemed like an extreme. But if that meant consistently higher performance, then sure, that would make sense. So I wanted to test this theory. I wanted to find out exactly how fast node.js was compared to .NET - as empirically as possible. So I wanted to come up with a problem that involved IO (ideally not involving a database), and some computation. And I wanted to do this under load, so that I could see how each system behaves under pressure. I came up with the following problem: I have approximately 200 files, each containing somewhere between 10 to 30 thousand random decimals. Each request to the server would contain a number such as: /1 or /120, the service would then open the corresponding file, read the contents, and sort them in memory and output the median value. That’s it. Our goal is to reach a maximum of 200 simultaneous requests, so the idea is that each request would have a corresponding file without ever overlapping. I also wanted to align the two platforms (.NET and Node.js). For instance, I didn’t want to host the .NET service on IIS because it seemed unfair to pay the cost of all the things IIS comes with (caching, routing, performance counters), only to never use them. I also avoided the entire ASP.NET pipeline, including MVC for the same reasons, they all come with features, which we don’t care about in this case. Okay, so both .NET and Node.JS will create a basic HTTP listener. What about client? The plan here is to create a simple .NET console app that drives load to the service. While the client is written in .NET, the key point here is that we test both .NET and Node.JS services using the same client. So at a minimum how the client is written is a negligible problem. Before we delve into the details, let’s look the graph that shows us the results: On an average Node.js wins hands down. Even though there are few spikes that could be attributed to various disk related anomalies, as some of the readers have eluded to. I also want to clarify that if you look at the graph carefully you start to see that the two lines start to intersect towards the end of the test run, while that might start to give you the impression that overtime the performance for .NET and node.js converge the reality is .NET starts to suffer even more over time. Let’s look at each aspect of this test more carefully. We’ll start with the client, the client uses a HttpClient to drive requests to the service. The response times are maintained on the client side so that there aren’t any drastic implementation difference on the service that could impact our numbers. Notice that I avoided doing any Console.Write (which blocks) until the very end.\npublic void Start() { Task[] tasks = new Task[this.tasks]; for (int i = 0; i \u003c this.tasks; ++i) { tasks[i] = this.Perform(i); } Task.WaitAll(tasks); result.ToList().ForEach(Console.WriteLine); } public async Task Perform(int state) { string url = String.Format(\"{0}{1}\", this.baseUrl, state.ToString().PadLeft(3, '0')); var client = new HttpClient(); Stopwatch timer = new Stopwatch(); timer.Start(); string result = await client.GetStringAsync(url); timer.Stop(); this.result.Enqueue(String.Format(\"{0,4}\\t{1,5}\\t{2}\", url, timer.ElapsedMilliseconds, result)); } With that client, we can start looking at the service. First we’ll start with the node.js implementation. One of the beauties of node.js is it’s succinct syntax. With less than 40 lines of code we are able to fork processes based on the number of CPU cores and share the CPU-bound tasks amongst them.\nvar http = require('http'); var fs = require('fs'); var cluster = require('cluster'); var numCPUs = require('os').cpus().length; if (cluster.isMaster) { // Fork workers. for (var i = 0; i \u003c numCPUs; i++) { cluster.fork(); } cluster.on('exit', function(worker, code, signal) { console.log('worker ' + worker.process.pid + ' died'); }); } else { http.createServer(function(request, response) { var file = parseInt(request.url.substring(1)); file = file % 200; file = String(\"000\" + file).slice(-3); // read the file fs.readFile('../data/input'+file+'.txt', 'ascii', function(err, data) { if(err) { response.writeHead(400, {'Content-Type':'text/plain'}); response.end(); } else { var results = data.toString().split(\"\\r\\n\"); results.sort(); response.writeHead(200, {'Content-Type': 'text/plain'}); response.end('input'+file+'.txt\\t' + results[(parseInt(results.length/2))]); } }); }).listen(8080, '127.0.0.1'); } console.log('Server running at http://127.0.0.1:8080/') And lastly, let’s look at the .NET service implementation. Needless to say we are using .NET 4.5, with all the glories of async/await. As I mentioned earlier, I wanted to compare purely .NET without IIS or ASP.NET, so I started off with a simple HTTP listener:\npublic async Task Start() { while (true) { var context = await this.listener.GetContextAsync(); this.ProcessRequest(context); } } With that I am able to start processing each request, as requests come in I read the file stream asynchronously so I am not blocking my Threadpool thread, and perform the in-memory sort which is a simple Task that wraps the Array.Sort. With .NET I could have severely improved performance in this area by using parallel sorting algorithms which come right of the parallel extensions, but I choose not to because that really isn’t the point of this test.\nprivate async void ProcessRequest(HttpListenerContext context) { try { var filename = this.GetFileFromUrl(context.Request.Url.PathAndQuery.Substring(1)); string rawData = string.Empty; using (StreamReader reader = new StreamReader(Path.Combine(dataDirectory, filename))) { rawData = await reader.ReadToEndAsync(); } var sorted = await this.SortAsync(context, rawData); var response = encoding.GetBytes(String.Format(\"{0}\\t{1}\", filename, sorted[sorted.Length / 2])); await context.Response.OutputStream.WriteAsync(response, 0, response.Length); context.Response.StatusCode = (int)HttpStatusCode.OK; } catch(Exception e) { context.Response.StatusCode = (int)HttpStatusCode.BadRequest; Console.WriteLine(e.Message); } finally { context.Response.Close(); } } private async Task\u003cstring[]\u003e SortAsync(HttpListenerContext context, string rawData) { return await Task.Factory.StartNew(() =\u003e { var array = rawData.Split(new string[] { \"\\r\\n\" }, StringSplitOptions.RemoveEmptyEntries); Array.Sort(array); return array; }); } You can download the entire source code, this zip file includes both client, and service sources for both .NET and node.js. It also includes a tool to generate the random number files, so that you can run the tests on your local machine. You will also find the raw numbers in the zip file. I hope this was useful to you all as you’re deciding to choose the next framework to build your services on. For most startups the key pivot point is performance, scalability over anything else and node.js clearly shines as we’ve shown today. Also, please remember some of the comments below are based on the original article which was using the async NPM package. This article has since been updated with the corrected information.\n","wordCount":"1289","inLanguage":"en","datePublished":"2013-03-26T08:57:39Z","dateModified":"2013-03-26T08:57:39Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.salmanq.com/blog/net-and-node-js-performance-comparison/"},"publisher":{"@type":"Organization","name":"Salman Quazi","logo":{"@type":"ImageObject","url":"https://www.salmanq.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.salmanq.com/ accesskey=h title="Salman Quazi (Alt + H)">Salman Quazi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.salmanq.com/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://github.com/splusq/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.linkedin.com/in/salmanquazi/ title=LinkedIn><span>LinkedIn</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.twitter.com/splusq title=Twitter><span>Twitter</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>.NET and Node.JS - Performance Comparison (Updated)</h1><div class=post-meta><span title='2013-03-26 08:57:39 +0000 UTC'>March 26, 2013</span>&nbsp;·&nbsp;7 min</div></header><div class=post-content><p><strong>Update (3/31/2013 - 11:41 PM PST):</strong></p><p>This article has been updated! As most readers have commented the node.js async package is not asynchronous, which is what the original article was based on. I made an assumption I should not have. I have since rerun the tests taking this into account, as well as some of the changes recommended by <a href=http://guillaume86.calepin.co/dotnet-vs-nodejs-performance.html>Guillaume Lecomte</a>. I have decided to update this existing post so that there&rsquo;s no confusion in the future with the data. Thank you everyone for all the comments, posts and keeping me sane.</p><p><strong>Update (3/29/2013 - 3:43 PM PST):</strong></p><p>There&rsquo;s been a lot of valid comments around the use of the async NPM package for node.js which are valid. I will take them into account and re-run these tests. If you talk to any silicon valley startup today chances are you will hear about <a href=http://nodejs.org/>node.js</a>. One of the key reasons most argue is that node.js is fast, scalable because of forced non-blocking IO, and it&rsquo;s efficient use of a single threaded model. I personally love JavaScript, so being able to use JavaScript on the server side seemed like a key gain. But I was never really sold into the notion that node.js is supremely fast because there aren&rsquo;t any context switches and thread synchronizations. We all know these practices should be avoided at all costs in any multi-threaded program, but to give it all away seemed like an extreme. But if that meant consistently higher performance, then sure, that would make sense. So I wanted to test this theory. I wanted to find out exactly how fast node.js was compared to .NET - as empirically as possible. So I wanted to come up with a problem that involved IO (ideally not involving a database), and some computation. And I wanted to do this under load, so that I could see how each system behaves under pressure. I came up with the following problem: I have approximately 200 files, each containing somewhere between 10 to 30 thousand random decimals. Each request to the server would contain a number such as: /1 or /120, the service would then open the corresponding file, read the contents, and sort them in memory and output the median value. That&rsquo;s it. Our goal is to reach a maximum of 200 simultaneous requests, so the idea is that each request would have a corresponding file without ever overlapping. I also wanted to align the two platforms (.NET and Node.js). For instance, I didn&rsquo;t want to host the .NET service on IIS because it seemed unfair to pay the cost of all the things IIS comes with (caching, routing, performance counters), only to never use them. I also avoided the entire ASP.NET pipeline, including MVC for the same reasons, they all come with features, which we don&rsquo;t care about in this case. Okay, so both .NET and Node.JS will create a basic HTTP listener. What about client? The plan here is to create a simple .NET console app that drives load to the service. While the client is written in .NET, the key point here is that we test both .NET and Node.JS services using the same client. So at a minimum how the client is written is a negligible problem. Before we delve into the details, let&rsquo;s look the graph that shows us the results: <img loading=lazy src=/2013/03/performance-comparison-net-nodejs.png alt=".NET and Node.JS - Performance Comparison"></p><p>On an average Node.js wins hands down. Even though there are few spikes that could be attributed to various disk related anomalies, as some of the readers have eluded to. I also want to clarify that if you look at the graph carefully you start to see that the two lines start to intersect towards the end of the test run, while that might start to give you the impression that overtime the performance for .NET and node.js converge the reality is .NET starts to suffer even more over time. Let&rsquo;s look at each aspect of this test more carefully. We&rsquo;ll start with the client, the client uses a <a href=http://msdn.microsoft.com/en-us/library/system.net.http.httpclient.aspx>HttpClient</a> to drive requests to the service. The response times are maintained on the client side so that there aren&rsquo;t any drastic implementation difference on the service that could impact our numbers. Notice that I avoided doing any Console.Write (which blocks) until the very end.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span> <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Task[] tasks = <span style=color:#66d9ef>new</span> Task[<span style=color:#66d9ef>this</span>.tasks];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#66d9ef>this</span>.tasks; ++i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        tasks[i] = <span style=color:#66d9ef>this</span>.Perform(i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Task.WaitAll(tasks);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    result.ToList().ForEach(Console.WriteLine);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task Perform(<span style=color:#66d9ef>int</span> state)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> url = String.Format(<span style=color:#e6db74>&#34;{0}{1}&#34;</span>, <span style=color:#66d9ef>this</span>.baseUrl, state.ToString().PadLeft(<span style=color:#ae81ff>3</span>, <span style=color:#e6db74>&#39;0&#39;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> client = <span style=color:#66d9ef>new</span> HttpClient();
</span></span><span style=display:flex><span>    Stopwatch timer = <span style=color:#66d9ef>new</span> Stopwatch();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    timer.Start();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> result = <span style=color:#66d9ef>await</span> client.GetStringAsync(url);
</span></span><span style=display:flex><span>    timer.Stop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.result.Enqueue(String.Format(<span style=color:#e6db74>&#34;{0,4}\t{1,5}\t{2}&#34;</span>, url, timer.ElapsedMilliseconds, result));
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>With that client, we can start looking at the service. First we&rsquo;ll start with the node.js implementation. One of the beauties of node.js is it&rsquo;s succinct syntax. With less than 40 lines of code we are able to fork processes based on the number of CPU cores and share the CPU-bound tasks amongst them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>http</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;http&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>fs</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;fs&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>cluster</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;cluster&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>numCPUs</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;os&#39;</span>).<span style=color:#a6e22e>cpus</span>().<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>isMaster</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Fork workers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>numCPUs</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>fork</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cluster</span>.<span style=color:#a6e22e>on</span>(<span style=color:#e6db74>&#39;exit&#39;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>worker</span>, <span style=color:#a6e22e>code</span>, <span style=color:#a6e22e>signal</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;worker &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>worker</span>.<span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>pid</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39; died&#39;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>} 
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>createServer</span>(<span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>request</span>, <span style=color:#a6e22e>response</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>file</span> <span style=color:#f92672>=</span> parseInt(<span style=color:#a6e22e>request</span>.<span style=color:#a6e22e>url</span>.<span style=color:#a6e22e>substring</span>(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>file</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>file</span> <span style=color:#f92672>%</span> <span style=color:#ae81ff>200</span>;
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>file</span> <span style=color:#f92672>=</span> String(<span style=color:#e6db74>&#34;000&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>file</span>).<span style=color:#a6e22e>slice</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// read the file
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>fs</span>.<span style=color:#a6e22e>readFile</span>(<span style=color:#e6db74>&#39;../data/input&#39;</span><span style=color:#f92672>+</span><span style=color:#a6e22e>file</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#39;.txt&#39;</span>, <span style=color:#e6db74>&#39;ascii&#39;</span>, <span style=color:#66d9ef>function</span>(<span style=color:#a6e22e>err</span>, <span style=color:#a6e22e>data</span>) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>err</span>) {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>writeHead</span>(<span style=color:#ae81ff>400</span>, {<span style=color:#e6db74>&#39;Content-Type&#39;</span><span style=color:#f92672>:</span><span style=color:#e6db74>&#39;text/plain&#39;</span>});
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>end</span>();
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>results</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>toString</span>().<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#34;\r\n&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>results</span>.<span style=color:#a6e22e>sort</span>();
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>writeHead</span>(<span style=color:#ae81ff>200</span>, {<span style=color:#e6db74>&#39;Content-Type&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;text/plain&#39;</span>});
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>response</span>.<span style=color:#a6e22e>end</span>(<span style=color:#e6db74>&#39;input&#39;</span><span style=color:#f92672>+</span><span style=color:#a6e22e>file</span><span style=color:#f92672>+</span><span style=color:#e6db74>&#39;.txt\t&#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>results</span>[(parseInt(<span style=color:#a6e22e>results</span>.<span style=color:#a6e22e>length</span><span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>))]);
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		});
</span></span><span style=display:flex><span>	}).<span style=color:#a6e22e>listen</span>(<span style=color:#ae81ff>8080</span>, <span style=color:#e6db74>&#39;127.0.0.1&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;Server running at http://127.0.0.1:8080/&#39;</span>) 
</span></span></code></pre></div><p>And lastly, let&rsquo;s look at the .NET service implementation. Needless to say we are using .NET 4.5, with all the <a href=http://blogs.msdn.com/b/toub/>glories of async/await</a>. As I mentioned earlier, I wanted to compare purely .NET without IIS or ASP.NET, so I started off with <a href=http://msdn.microsoft.com/en-us/library/system.net.httplistener.aspx>a simple HTTP listener</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task Start()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> context = <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.listener.GetContextAsync();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.ProcessRequest(context);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>With that I am able to start processing each request, as requests come in I read the file stream asynchronously so I am not blocking my Threadpool thread, and perform the in-memory sort which is a simple Task that wraps the Array.Sort. With .NET I could have severely improved performance in this area by using parallel sorting algorithms which come right of the <a href=http://msdn.microsoft.com/en-us/library/dd460717.aspx>parallel extensions</a>, but I choose not to because that really isn&rsquo;t the point of this test.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> ProcessRequest(HttpListenerContext context)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> filename = <span style=color:#66d9ef>this</span>.GetFileFromUrl(context.Request.Url.PathAndQuery.Substring(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> rawData = <span style=color:#66d9ef>string</span>.Empty;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>using</span> (StreamReader reader = <span style=color:#66d9ef>new</span> StreamReader(Path.Combine(dataDirectory, filename)))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            rawData = <span style=color:#66d9ef>await</span> reader.ReadToEndAsync();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> sorted = <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.SortAsync(context, rawData);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> response = encoding.GetBytes(String.Format(<span style=color:#e6db74>&#34;{0}\t{1}&#34;</span>, filename, sorted[sorted.Length / <span style=color:#ae81ff>2</span>]));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> context.Response.OutputStream.WriteAsync(response, <span style=color:#ae81ff>0</span>, response.Length);
</span></span><span style=display:flex><span>        context.Response.StatusCode = (<span style=color:#66d9ef>int</span>)HttpStatusCode.OK;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>catch</span>(Exception e) 
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        context.Response.StatusCode = (<span style=color:#66d9ef>int</span>)HttpStatusCode.BadRequest;
</span></span><span style=display:flex><span>        Console.WriteLine(e.Message);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>finally</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        context.Response.Close();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> Task&lt;<span style=color:#66d9ef>string</span>[]&gt; SortAsync(HttpListenerContext context, <span style=color:#66d9ef>string</span> rawData)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> Task.Factory.StartNew(() =&gt;
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> array = rawData.Split(<span style=color:#66d9ef>new</span> <span style=color:#66d9ef>string</span>[] { <span style=color:#e6db74>&#34;\r\n&#34;</span> }, StringSplitOptions.RemoveEmptyEntries);
</span></span><span style=display:flex><span>        Array.Sort(array);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> array;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>You can <a href=/2013/03/nodenetperf.zip>download the entire source code</a>, this zip file includes both client, and service sources for both .NET and node.js. It also includes a tool to generate the random number files, so that you can run the tests on your local machine. You will also find the raw numbers in the zip file. I hope this was useful to you all as you&rsquo;re deciding to choose the next framework to build your services on. For most startups the key pivot point is performance, scalability over anything else and node.js clearly shines as we&rsquo;ve shown today. Also, please remember some of the comments below are based on the original article which was using the <a href=https://github.com/caolan/async>async</a> NPM package. This article has since been updated with the corrected information.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.salmanq.com/tags/uncategorized/>Uncategorized</a></li></ul><nav class=paginav><a class=prev href=https://www.salmanq.com/blog/introduction-to-machine-learning-2/><span class=title>« Prev</span><br><span>Introduction to Machine Learning</span></a>
<a class=next href=https://www.salmanq.com/blog/improving-wordpress-site-speed-on-iis/><span class=title>Next »</span><br><span>Improving Wordpress site speed on IIS</span></a></nav></footer><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.salmanq.com/>Salman Quazi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>