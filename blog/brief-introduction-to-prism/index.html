<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.120.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Brief introduction to PRISM &#183; Salman Quazi</title>
<meta name=description content><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/poole.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/syntax.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><style type=text/css>.sidebar-about h1{font-size:1.95rem;font-weight:400}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-K4WVH5P91F"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K4WVH5P91F")</script></head><body class=theme-base-08><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://www.salmanq.com/><h1>Salman Quazi</h1></a><p class=lead>Engineering Manager for Microsoft Azure Cognitive Services in Mountain View, CA.</p></div><nav><ul class=sidebar-nav><li><a href=https://www.salmanq.com/>Home</a></li><li><a href=/blog/>Blog</a></li><li><a href=https://github.com/splusq/>Github</a></li><li><a href=https://www.linkedin.com/in/salmanquazi/>LinkedIn</a></li><li><a href=https://www.twitter.com/splusq>Twitter</a></li></ul></nav><p>Opinions are my own.</p></div></aside><main class="content container"><div class=post><h1>Brief introduction to PRISM</h1><time datetime=2011-03-08T14:55:10Z class=post-date>Tue, Mar 8, 2011</time><p>Before I go into the technical details of this article. I want to provide some context for this discussion. So we are using <a href=http://compositewpf.codeplex.com/>PRISM</a> to develop a user-interface (UI) platform in the context of a Silverlight (but they apply to WPF also). The idea behind the UI platform is we will provide the basic functional look and feel and various plumbing (such as security, service encapsulation, messaging and exception handling, among others) and allow others to develop modules/components on top. PRISM allows us to do this quite well. Let’s assume for a second, you have a system where a user can initiate an order, and then track the shipment status of that order. PRISM allows us to separate the concerns of this applications into two distinct tasks. (1) ordering, and (2) shipment tracking (and perhaps even further, but let’s keep it simple). Each of these could be developed as separate modules, and therefore separate DLLs, and possibly by separate teams. In the end, with PRISM, we can <strong><em>dynamically compose</em></strong> these at runtime even though they are independent components. So if you can imagine for a second, all the base functionality that we talked earlier is hosted in a component itself usually referred to as the Shell. The Shell is like the hosting application, where everything comes together. If there’s any resemblance to web applications, as Masterpage is to a ASP.NET page, a Shell is to a Silverlight/WPF application. That’s one way to look at it. So that’s the general overview for our discussion. And you can get a lot of good content about PRISM from Karl Shifflett, John Papa. With PRISM (and also few other technologies like MEF) what we are able to do is we are able to surface modules on the fly based on a modules catalog (one of many ways). One key architectural decision we made early on was that the Shell would be independent of the modules – meaning the Shell does not have any strong references to the modules. This allows us to introduce new modules without actually recompiling the Shell. But many examples out there do exactly that, they either (1) add strong references to Modules from the Shell or (2) they use something known as a ModulesCatalog file. Which is a XAML file that weakly defines the modules list. But again, the ModulesCatalog.xaml file is backed into the Shell – and therefore part of the XAP. That brings us back to the some of the same restrictions. Part of the problem we have is we have several teams, teams that are out of control, developing modules. </p><p>All these modules contribute to the same application. Obviously a single team owns the Shell and they are responsible for it, and have access to it. So if there’s any dependency whatsoever on the shell (such as adding references, or editing a ModulesCatalog file) during the onboarding process of a module, then we have a problem. <strong>That’s where dynamic modules catalogs come in.</strong> With this approach we are able to decouple the shell even further, and move the catalog to a separate project. In our case, we moved the ModulesCatalog to the hosting web project. So let’s assume you have a <code>ModulesCatalog</code> file that looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;Modularity:ModuleCatalog</span> <span style=color:#a6e22e>xmlns=</span><span style=color:#e6db74>&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xmlns:x=</span><span style=color:#e6db74>&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xmlns:sys=</span><span style=color:#e6db74>&#34;clr-namespace:System;assembly=mscorlib&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>xmlns:Modularity=</span><span style=color:#e6db74>&#34;clr-namespace:Microsoft.Practices.Prism.Modularity;assembly=Microsoft.Practices.Prism&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;Modularity:ModuleInfo</span> <span style=color:#a6e22e>Ref=</span><span style=color:#e6db74>&#34;Modules.Order.xap&#34;</span> <span style=color:#a6e22e>ModuleName=</span><span style=color:#e6db74>&#34;OrderModule&#34;</span> <span style=color:#a6e22e>ModuleType=</span><span style=color:#e6db74>&#34;Modules.Order.OrderModule, Modules.Order&#34;</span> <span style=color:#a6e22e>InitializationMode=</span><span style=color:#e6db74>&#34;OnDemand&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/Modularity:ModuleCatalog&gt;</span> 
</span></span></code></pre></div><p>And we want to load this dynamically from the Shell (which is a Silverlight application).  We can do this during the Application_Startup which generally initializes the bootstrapper. However, in our case we load the ModulesCatalog via a WebClient call first, and send the stream to the boostrapper.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> Application_Startup(<span style=color:#66d9ef>object</span> sender, StartupEventArgs e) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> client = <span style=color:#66d9ef>new</span> WebClient();
</span></span><span style=display:flex><span>        client.OpenReadCompleted += <span style=color:#66d9ef>new</span> OpenReadCompletedEventHandler((s, ev) =&gt; {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> bootsrap = <span style=color:#66d9ef>new</span> Bootstrapper(ev.Result);
</span></span><span style=display:flex><span>            bootsrap.Run();
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        client.OpenReadAsync(<span style=color:#66d9ef>new</span> System.Uri(<span style=color:#e6db74>@&#34;Metadata\ModulesCatalog.xml&#34;</span>, System.UriKind.Relative));
</span></span><span style=display:flex><span>    } 
</span></span></code></pre></div><p>Once that’s done, we can :</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> IModuleCatalog CreateModuleCatalog() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Microsoft.Practices.Prism.Modularity.ModuleCatalog.CreateFromXaml(stream);
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>Going forward I will talk more about PRISM, and MEF (Modularity Extensibility Framework). If there’s anything specific around these technologies you would like me to talk about please bring them up in your comments.</p></div><h2>Comments</h2><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></main></body></html>