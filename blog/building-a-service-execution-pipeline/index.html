<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.134.2"><meta name=viewport content="width=device-width,initial-scale=1"><title>Building a service execution pipeline &#183; Salman Quazi</title>
<meta name=description content><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/poole.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/syntax.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><style type=text/css>.sidebar-about h1{font-size:1.95rem;font-weight:400}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-K4WVH5P91F"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K4WVH5P91F")</script></head><body class=theme-base-08><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://www.salmanq.com/><h1>Salman Quazi</h1></a><p class=lead>Director of Engineering for Microsoft Azure OpenAI in Mountain View, CA.</p></div><nav><ul class=sidebar-nav><li><a href=https://www.salmanq.com/>Home</a></li><li><a href=/blog/>Blog</a></li><li><a href=https://github.com/splusq/>Github</a></li><li><a href=https://www.linkedin.com/in/salmanquazi/>LinkedIn</a></li><li><a href=https://www.twitter.com/splusq>Twitter</a></li></ul></nav><p>Opinions are my own.</p></div></aside><main class="content container"><div class=post><h1>Building a service execution pipeline</h1><time datetime=2013-04-08T05:19:13Z class=post-date>Mon, Apr 8, 2013</time><p>Most software built today have a notion of a client and a service. This is even more true with mobile/web applications because you want your client apps to do as little as possible, and your service to do most of the heavy lifting. This allows you to improve your service without requiring constant client updates. Also since you have a single service that serves potentially various native clients (iOS, Android, or Windows Phone), being able to update it independently of your users gives you a clear competitive edge. So today I want to focus on building a service based on this notion of a &ldquo;pipeline&rdquo;. Most .NET client/service frameworks already have this concept. For instance, Windows Communication Foundation (WCF) has an execution pipeline, and so does ASP.NET. This allows you to extend the behavior of these frameworks at various points during the execution. But that&rsquo;s not really what I want to talk about today. I want to talk about how <em>you can build</em> your services such that you can add/remove functionality using a pipeline-style execution. As we are talking about the implementation of this pipeline I also want to take this opportunity to discuss good software design practices, and it&rsquo;s uses. <img src=/2013/04/service-execution-pipeline.png alt=service-execution-pipeline></p><h3 id=motivations>Motivations</h3><p><strong>Building distinct components that perform a very specific functionality and nothing more</strong></p><p>If you don&rsquo;t build services this way, our natural inclination as developers, will be to pile on top of the code that already exists. Think about authentication for example, your service may do user authentication against a local database but you want to add support for Facebook, or Twitter. Assuming that you have a component that&rsquo;s responsible for doing the authentication with a local database today, when you want to support these additional parties, the immediate thought is to update this authentication logic to support it. The problem with this is you simply cannot tease apart facebook, from twitter from your local authentication. They are all in one bucket. Either you have them all or you don&rsquo;t. And the same can be said about many other types of functionality within your system.</p><p><strong>Being able to enable/disable functionality of your service without code change</strong></p><p>One of key decisions you need to make when building a service is to recognize the inevitable truth that dependencies of your services will break down. Period. If you program knowing this fact, then you are more likely to build resiliant systems that can withstand these dramatic erruptions. One of the key ways to do this is to design your services so that they can deteriorate in terms of performance or functionality instead of completely breaking down. The only way to do this properly is if you can identify and isolate specific functionalities in your system and have the ability to enable/disable them. Like we said earlier if all your functionalities are burried in a bucket of water, you&rsquo;ve already muddied it - there&rsquo;s nothing you can do when a bad drop of oil is poured in. But if each arbitrary subset of water droplets were contained in a packet, and you could identify which was the bad breed, you could easily remove it from the container and let the rest of them continue to function.</p><h3 id=solution>Solution</h3><p>So the way to solve this problem is to build on somewhat of a modified <a href=http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern>chain-of-responsibility principle</a>. Where each item in the chain is handling a single responsibility and then forwarding the request over to the next party in the chain and the execution continues. Theoratically every non-shared chunk of code can become an item in the chain but then it becomes difficult to stich them together. So the right balance is to isolate a feature in an item, and then string together the chain to build the overall functionality. But we are sort of getting ahead of ourselves. In order to build a fully functional high performance, execution pipeline, we&rsquo;ll need to build many foundational pieces. So instead of doing that, today we will start with a simple, synchronous, one-way, non-hierarchial execution pipeline. Let&rsquo;s get started with a simple console application:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// configure the MEF container</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> container = ConfigureMef())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// create a pipeline flow - logging/fake response/terminate</span>
</span></span><span style=display:flex><span>        IPipeline pipeline = <span style=color:#66d9ef>new</span> LoggingPipeline(<span style=color:#66d9ef>new</span> FakeResponsePipeline());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// inject the property</span>
</span></span><span style=display:flex><span>        container.ComposeExportedValue&lt;IPipeline&gt;(pipeline);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// resolve the root type - a simple http server</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> server = container.GetExportedValue&lt;Server&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// start the server</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> service = server.Start(<span style=color:#e6db74>@&#34;http://127.0.0.1:8080/&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// keep accepting connections</span>
</span></span><span style=display:flex><span>        service.Wait();
</span></span><span style=display:flex><span>    } <span style=color:#75715e>// dispose</span>
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>First notice that I am using the <a href=http://mef.codeplex.com/>Managed Extensibility Framework</a> as my <a href=http://en.wikipedia.org/wiki/Dependency_injection>DI container</a>. Any other <a href=http://www.hanselman.com/blog/ListOfNETDependencyInjectionContainersIOC.aspx>DI container</a> would work in this case, but MEF allowed me to stick with the .NET framework and also didn&rsquo;t need any additional configuration to work - which was nice for this simple example. So the first thing to notice is that we have an interface for our Pipeline which we are preparing externally from the actual service. In this case we are saying that the pipeline will consist of Logging and a FakeResponse - and injecting that to our server. Our server then will execute the pipeline following the chain. It&rsquo;s easy to see how we can externalize this configuration to a config file allowing us to modify the behavior of the service without necessarily making a code change. We will talk more about this just a little later, for now let&rsquo;s look at how the server is configured:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[Export]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Server</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IHttpListener listener;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IPipeline pipeline;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [ImportingConstructor]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Server(IHttpListener listener, IPipeline pipeline)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.listener = listener;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.pipeline = pipeline;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task Start(<span style=color:#66d9ef>string</span> address)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.listener.Prefixes.Add(address);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.listener.Start();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// keep listening</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// wait for a listener</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> context = <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.listener.GetContextAsync().ConfigureAwait(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// initiate the pipeline and forget</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.pipeline.Continue(context);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>This is probably one of the most simplest HTTP servers. It accepts a requests and passes it forward to the first item in the pipeline. That&rsquo;s it. Recall, the pipeline was built external to the server and injected to it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[InheritedExport]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IPipeline</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Continue(HttpListenerContext listenerContext);
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>The execution pipeline interface is extremely simple. It accepts a Continuation to the next execution pipeline. One of things you want to do when you build interfaces is to think of the minimal set that satifies what you are trying to do. The leaner your interfaces, the less likely they will change, and therefore have less impact on the overall system. The recommendaton for most interfaces is to have no more than 3-4 methods. The .NET Framework interfaces not surprisingly has 3.75 members, with a methods-to-properties ratio of 3.5:1. If your interfaces start to have more than 10 methods, you&rsquo;re probably building more than one responsiblity in an interface and there&rsquo;s probably an opportunity to separate them. This task is often referred to as decomposition. Now that we have the base interface we need to build an abstract concept that allows to move to the next item in the pipeline. Because interface does not define that, the interface just says you should be able to continue. For that we create an abstract BaseContinuationPipeline.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BaseContinuationPipeline</span> : IPipeline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> IPipeline forward;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> BaseContinuationPipeline()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// default is the terminating pipeline</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.forward = <span style=color:#66d9ef>new</span> TerminatingPipeline(); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> BaseContinuationPipeline(IPipeline forward)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.forward = forward;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Continue(HttpListenerContext listenerContext)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Task.Run(() =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// execute the &#34;abstract&#34; action</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.Execute(listenerContext);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// continue to the next action</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.forward.Continue(listenerContext);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> Execute(HttpListenerContext listenerContext);
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>There are few things to point out here: the first thing is the default forward continuation to the pipeline is this special item in the pipeline called a terminating pipeline. It&rsquo;s sole purpose is to end the request. This pattern of using a special object to handle empty set is referred to as the <a href=http://en.wikipedia.org/wiki/Null_Object_pattern>Null Object Pattern</a>. There were several ways to implement this special case. For instance, I could have simply left the forward object to null, and if it was null - prevent the forwarding and end the request. However, the problem with this is you are implementing a special case while your normal control flow of your logic can support it. The second thing is there might be other parts of the pipeline where I may decide to end the request, in which case I only need to forward it to the terminating pipeline (no repeating logic). One good sign of a well designed software is it&rsquo;s overall lack of conditional statements. If you think about it conditional statements (if/else, switch) are sort of a forced behavior to your normal control flow. Now I am not saying remove all conditional statements, that would be absurd there is no way to check if 5 > 3 without actually doing a if statement but for business objects you should think twice if you are constantly checking if the object is null. Also notice that the default is the terminating pipeline. This means even if the caller does not pass any feature sets to the pipeline the default behavior will be stop the execution. You always want to do a safe design, meaning that your APIs are full proof such that no matter how you interact with it the baseline behavior is at least functional. So let&rsquo;s keep moving forward. This abstract class does not know about any features so it simply describes how to move forward to the next continuation and keeps the execution abstract. The current item in the pipeline is executed by doing this.Execute, and then the request is forwarded to the next responsible party. That&rsquo;s it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TerminatingPipeline</span> : IPipeline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Continue(HttpListenerContext listenerContext)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// end the response stream</span>
</span></span><span style=display:flex><span>        listenerContext.Response.Close();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// no more forwarding</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>So like we talked about before the terminating pipeline implements IPipeline interface and it&rsquo;s continuation is to simply to end the request and there&rsquo;s no where to forward to since this is always going to be the last item in the list. And to close, let&rsquo;s look at the two items in our pipeline, the logging and the fakeresponse:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggingPipeline</span> : BaseContinuationPipeline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> LoggingPipeline(IPipeline forward) : <span style=color:#66d9ef>base</span>(forward) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(HttpListenerContext listenerContext)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(listenerContext.Request.Url);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FakeResponsePipeline</span> : BaseContinuationPipeline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(HttpListenerContext listenerContext)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> response = <span style=color:#e6db74>&#34;hello world&#34;</span>;
</span></span><span style=display:flex><span>        listenerContext.Response.OutputStream.WriteAsync(ASCIIEncoding.ASCII.GetBytes(response), <span style=color:#ae81ff>0</span>, response.Length);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>They both implement the BaseContinuationPipeline because they both support continuations. In fact, all our pipeline elements will implement continuations except the special TerminatingPipeline. The logging pipeline simply prints the incoming URL, and the FakeResponse writes Hello World to the output. With that we have a foundation to build something on top of. I will continue this discussion with more functionality with support for hierarchies, non-sequential and state-ful pipelines. All of which will be required to build a fully functional service.</p></div><h2>Comments</h2><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></main></body></html>