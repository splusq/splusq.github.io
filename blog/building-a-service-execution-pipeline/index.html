<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Building a service execution pipeline | Salman Quazi</title><meta name=keywords content="Uncategorized"><meta name=description content="Most software built today have a notion of a client and a service. This is even more true with mobile/web applications because you want your client apps to do as little as possible, and your service to do most of the heavy lifting. This allows you to improve your service without requiring constant client updates. Also since you have a single service that serves potentially various native clients (iOS, Android, or Windows Phone), being able to update it independently of your users gives you a clear competitive edge."><meta name=author content="Me"><link rel=canonical href=https://www.salmanq.com/blog/building-a-service-execution-pipeline/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://www.salmanq.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.salmanq.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.salmanq.com/favicon-32x32.png><link rel=apple-touch-icon href=https://www.salmanq.com/apple-touch-icon.png><link rel=mask-icon href=https://www.salmanq.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-38742121-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Building a service execution pipeline"><meta property="og:description" content="Most software built today have a notion of a client and a service. This is even more true with mobile/web applications because you want your client apps to do as little as possible, and your service to do most of the heavy lifting. This allows you to improve your service without requiring constant client updates. Also since you have a single service that serves potentially various native clients (iOS, Android, or Windows Phone), being able to update it independently of your users gives you a clear competitive edge."><meta property="og:type" content="article"><meta property="og:url" content="https://www.salmanq.com/blog/building-a-service-execution-pipeline/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2013-04-08T05:19:13+00:00"><meta property="article:modified_time" content="2013-04-08T05:19:13+00:00"><meta property="og:site_name" content="Salman Quazi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a service execution pipeline"><meta name=twitter:description content="Most software built today have a notion of a client and a service. This is even more true with mobile/web applications because you want your client apps to do as little as possible, and your service to do most of the heavy lifting. This allows you to improve your service without requiring constant client updates. Also since you have a single service that serves potentially various native clients (iOS, Android, or Windows Phone), being able to update it independently of your users gives you a clear competitive edge."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://www.salmanq.com/blog/"},{"@type":"ListItem","position":2,"name":"Building a service execution pipeline","item":"https://www.salmanq.com/blog/building-a-service-execution-pipeline/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Building a service execution pipeline","name":"Building a service execution pipeline","description":"Most software built today have a notion of a client and a service. This is even more true with mobile/web applications because you want your client apps to do as little as possible, and your service to do most of the heavy lifting. This allows you to improve your service without requiring constant client updates. Also since you have a single service that serves potentially various native clients (iOS, Android, or Windows Phone), being able to update it independently of your users gives you a clear competitive edge.","keywords":["Uncategorized"],"articleBody":"Most software built today have a notion of a client and a service. This is even more true with mobile/web applications because you want your client apps to do as little as possible, and your service to do most of the heavy lifting. This allows you to improve your service without requiring constant client updates. Also since you have a single service that serves potentially various native clients (iOS, Android, or Windows Phone), being able to update it independently of your users gives you a clear competitive edge. So today I want to focus on building a service based on this notion of a “pipeline”. Most .NET client/service frameworks already have this concept. For instance, Windows Communication Foundation (WCF) has an execution pipeline, and so does ASP.NET. This allows you to extend the behavior of these frameworks at various points during the execution. But that’s not really what I want to talk about today. I want to talk about how you can build your services such that you can add/remove functionality using a pipeline-style execution. As we are talking about the implementation of this pipeline I also want to take this opportunity to discuss good software design practices, and it’s uses. Motivations Building distinct components that perform a very specific functionality and nothing more\nIf you don’t build services this way, our natural inclination as developers, will be to pile on top of the code that already exists. Think about authentication for example, your service may do user authentication against a local database but you want to add support for Facebook, or Twitter. Assuming that you have a component that’s responsible for doing the authentication with a local database today, when you want to support these additional parties, the immediate thought is to update this authentication logic to support it. The problem with this is you simply cannot tease apart facebook, from twitter from your local authentication. They are all in one bucket. Either you have them all or you don’t. And the same can be said about many other types of functionality within your system.\nBeing able to enable/disable functionality of your service without code change\nOne of key decisions you need to make when building a service is to recognize the inevitable truth that dependencies of your services will break down. Period. If you program knowing this fact, then you are more likely to build resiliant systems that can withstand these dramatic erruptions. One of the key ways to do this is to design your services so that they can deteriorate in terms of performance or functionality instead of completely breaking down. The only way to do this properly is if you can identify and isolate specific functionalities in your system and have the ability to enable/disable them. Like we said earlier if all your functionalities are burried in a bucket of water, you’ve already muddied it - there’s nothing you can do when a bad drop of oil is poured in. But if each arbitrary subset of water droplets were contained in a packet, and you could identify which was the bad breed, you could easily remove it from the container and let the rest of them continue to function.\nSolution So the way to solve this problem is to build on somewhat of a modified chain-of-responsibility principle. Where each item in the chain is handling a single responsibility and then forwarding the request over to the next party in the chain and the execution continues. Theoratically every non-shared chunk of code can become an item in the chain but then it becomes difficult to stich them together. So the right balance is to isolate a feature in an item, and then string together the chain to build the overall functionality. But we are sort of getting ahead of ourselves. In order to build a fully functional high performance, execution pipeline, we’ll need to build many foundational pieces. So instead of doing that, today we will start with a simple, synchronous, one-way, non-hierarchial execution pipeline. Let’s get started with a simple console application:\nstatic void Main(string[] args) { // configure the MEF container using (var container = ConfigureMef()) { // create a pipeline flow - logging/fake response/terminate IPipeline pipeline = new LoggingPipeline(new FakeResponsePipeline()); // inject the property container.ComposeExportedValue(pipeline); // resolve the root type - a simple http server var server = container.GetExportedValue(); // start the server var service = server.Start(@\"http://127.0.0.1:8080/\"); // keep accepting connections service.Wait(); } // dispose } First notice that I am using the Managed Extensibility Framework as my DI container. Any other DI container would work in this case, but MEF allowed me to stick with the .NET framework and also didn’t need any additional configuration to work - which was nice for this simple example. So the first thing to notice is that we have an interface for our Pipeline which we are preparing externally from the actual service. In this case we are saying that the pipeline will consist of Logging and a FakeResponse - and injecting that to our server. Our server then will execute the pipeline following the chain. It’s easy to see how we can externalize this configuration to a config file allowing us to modify the behavior of the service without necessarily making a code change. We will talk more about this just a little later, for now let’s look at how the server is configured:\n[Export] public class Server { private readonly IHttpListener listener; private readonly IPipeline pipeline; [ImportingConstructor] public Server(IHttpListener listener, IPipeline pipeline) { this.listener = listener; this.pipeline = pipeline; } public async Task Start(string address) { this.listener.Prefixes.Add(address); this.listener.Start(); // keep listening while (true) { // wait for a listener var context = await this.listener.GetContextAsync().ConfigureAwait(false); // initiate the pipeline and forget this.pipeline.Continue(context); } } } This is probably one of the most simplest HTTP servers. It accepts a requests and passes it forward to the first item in the pipeline. That’s it. Recall, the pipeline was built external to the server and injected to it.\n[InheritedExport] public interface IPipeline { void Continue(HttpListenerContext listenerContext); } The execution pipeline interface is extremely simple. It accepts a Continuation to the next execution pipeline. One of things you want to do when you build interfaces is to think of the minimal set that satifies what you are trying to do. The leaner your interfaces, the less likely they will change, and therefore have less impact on the overall system. The recommendaton for most interfaces is to have no more than 3-4 methods. The .NET Framework interfaces not surprisingly has 3.75 members, with a methods-to-properties ratio of 3.5:1. If your interfaces start to have more than 10 methods, you’re probably building more than one responsiblity in an interface and there’s probably an opportunity to separate them. This task is often referred to as decomposition. Now that we have the base interface we need to build an abstract concept that allows to move to the next item in the pipeline. Because interface does not define that, the interface just says you should be able to continue. For that we create an abstract BaseContinuationPipeline.\npublic abstract class BaseContinuationPipeline : IPipeline { private IPipeline forward; public BaseContinuationPipeline() { // default is the terminating pipeline this.forward = new TerminatingPipeline(); } public BaseContinuationPipeline(IPipeline forward) { this.forward = forward; } public virtual void Continue(HttpListenerContext listenerContext) { Task.Run(() =\u003e { // execute the \"abstract\" action this.Execute(listenerContext); // continue to the next action this.forward.Continue(listenerContext); }); } protected abstract void Execute(HttpListenerContext listenerContext); } There are few things to point out here: the first thing is the default forward continuation to the pipeline is this special item in the pipeline called a terminating pipeline. It’s sole purpose is to end the request. This pattern of using a special object to handle empty set is referred to as the Null Object Pattern. There were several ways to implement this special case. For instance, I could have simply left the forward object to null, and if it was null - prevent the forwarding and end the request. However, the problem with this is you are implementing a special case while your normal control flow of your logic can support it. The second thing is there might be other parts of the pipeline where I may decide to end the request, in which case I only need to forward it to the terminating pipeline (no repeating logic). One good sign of a well designed software is it’s overall lack of conditional statements. If you think about it conditional statements (if/else, switch) are sort of a forced behavior to your normal control flow. Now I am not saying remove all conditional statements, that would be absurd there is no way to check if 5 \u003e 3 without actually doing a if statement but for business objects you should think twice if you are constantly checking if the object is null. Also notice that the default is the terminating pipeline. This means even if the caller does not pass any feature sets to the pipeline the default behavior will be stop the execution. You always want to do a safe design, meaning that your APIs are full proof such that no matter how you interact with it the baseline behavior is at least functional. So let’s keep moving forward. This abstract class does not know about any features so it simply describes how to move forward to the next continuation and keeps the execution abstract. The current item in the pipeline is executed by doing this.Execute, and then the request is forwarded to the next responsible party. That’s it.\npublic class TerminatingPipeline : IPipeline { public void Continue(HttpListenerContext listenerContext) { // end the response stream listenerContext.Response.Close(); // no more forwarding } } So like we talked about before the terminating pipeline implements IPipeline interface and it’s continuation is to simply to end the request and there’s no where to forward to since this is always going to be the last item in the list. And to close, let’s look at the two items in our pipeline, the logging and the fakeresponse:\npublic class LoggingPipeline : BaseContinuationPipeline { public LoggingPipeline(IPipeline forward) : base(forward) { } protected override void Execute(HttpListenerContext listenerContext) { Console.WriteLine(listenerContext.Request.Url); } } public class FakeResponsePipeline : BaseContinuationPipeline { protected override void Execute(HttpListenerContext listenerContext) { string response = \"hello world\"; listenerContext.Response.OutputStream.WriteAsync(ASCIIEncoding.ASCII.GetBytes(response), 0, response.Length); } } They both implement the BaseContinuationPipeline because they both support continuations. In fact, all our pipeline elements will implement continuations except the special TerminatingPipeline. The logging pipeline simply prints the incoming URL, and the FakeResponse writes Hello World to the output. With that we have a foundation to build something on top of. I will continue this discussion with more functionality with support for hierarchies, non-sequential and state-ful pipelines. All of which will be required to build a fully functional service.\n","wordCount":"1799","inLanguage":"en","datePublished":"2013-04-08T05:19:13Z","dateModified":"2013-04-08T05:19:13Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.salmanq.com/blog/building-a-service-execution-pipeline/"},"publisher":{"@type":"Organization","name":"Salman Quazi","logo":{"@type":"ImageObject","url":"https://www.salmanq.com/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.salmanq.com/ accesskey=h title="Salman Quazi (Alt + H)">Salman Quazi</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.salmanq.com/blog/ title=Blog><span>Blog</span></a></li><li><a href=https://github.com/splusq/ title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.linkedin.com/in/salmanquazi/ title=LinkedIn><span>LinkedIn</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li><li><a href=https://www.twitter.com/splusq title=Twitter><span>Twitter</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Building a service execution pipeline</h1><div class=post-meta><span title='2013-04-08 05:19:13 +0000 UTC'>April 8, 2013</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Me</div></header><div class=post-content><p>Most software built today have a notion of a client and a service. This is even more true with mobile/web applications because you want your client apps to do as little as possible, and your service to do most of the heavy lifting. This allows you to improve your service without requiring constant client updates. Also since you have a single service that serves potentially various native clients (iOS, Android, or Windows Phone), being able to update it independently of your users gives you a clear competitive edge. So today I want to focus on building a service based on this notion of a &ldquo;pipeline&rdquo;. Most .NET client/service frameworks already have this concept. For instance, Windows Communication Foundation (WCF) has an execution pipeline, and so does ASP.NET. This allows you to extend the behavior of these frameworks at various points during the execution. But that&rsquo;s not really what I want to talk about today. I want to talk about how <em>you can build</em> your services such that you can add/remove functionality using a pipeline-style execution. As we are talking about the implementation of this pipeline I also want to take this opportunity to discuss good software design practices, and it&rsquo;s uses. <img loading=lazy src=/2013/04/service-execution-pipeline.png alt=service-execution-pipeline></p><h3 id=motivations>Motivations<a hidden class=anchor aria-hidden=true href=#motivations>#</a></h3><p><strong>Building distinct components that perform a very specific functionality and nothing more</strong></p><p>If you don&rsquo;t build services this way, our natural inclination as developers, will be to pile on top of the code that already exists. Think about authentication for example, your service may do user authentication against a local database but you want to add support for Facebook, or Twitter. Assuming that you have a component that&rsquo;s responsible for doing the authentication with a local database today, when you want to support these additional parties, the immediate thought is to update this authentication logic to support it. The problem with this is you simply cannot tease apart facebook, from twitter from your local authentication. They are all in one bucket. Either you have them all or you don&rsquo;t. And the same can be said about many other types of functionality within your system.</p><p><strong>Being able to enable/disable functionality of your service without code change</strong></p><p>One of key decisions you need to make when building a service is to recognize the inevitable truth that dependencies of your services will break down. Period. If you program knowing this fact, then you are more likely to build resiliant systems that can withstand these dramatic erruptions. One of the key ways to do this is to design your services so that they can deteriorate in terms of performance or functionality instead of completely breaking down. The only way to do this properly is if you can identify and isolate specific functionalities in your system and have the ability to enable/disable them. Like we said earlier if all your functionalities are burried in a bucket of water, you&rsquo;ve already muddied it - there&rsquo;s nothing you can do when a bad drop of oil is poured in. But if each arbitrary subset of water droplets were contained in a packet, and you could identify which was the bad breed, you could easily remove it from the container and let the rest of them continue to function.</p><h3 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h3><p>So the way to solve this problem is to build on somewhat of a modified <a href=http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern>chain-of-responsibility principle</a>. Where each item in the chain is handling a single responsibility and then forwarding the request over to the next party in the chain and the execution continues. Theoratically every non-shared chunk of code can become an item in the chain but then it becomes difficult to stich them together. So the right balance is to isolate a feature in an item, and then string together the chain to build the overall functionality. But we are sort of getting ahead of ourselves. In order to build a fully functional high performance, execution pipeline, we&rsquo;ll need to build many foundational pieces. So instead of doing that, today we will start with a simple, synchronous, one-way, non-hierarchial execution pipeline. Let&rsquo;s get started with a simple console application:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// configure the MEF container</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> (<span style=color:#66d9ef>var</span> container = ConfigureMef())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// create a pipeline flow - logging/fake response/terminate</span>
</span></span><span style=display:flex><span>        IPipeline pipeline = <span style=color:#66d9ef>new</span> LoggingPipeline(<span style=color:#66d9ef>new</span> FakeResponsePipeline());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// inject the property</span>
</span></span><span style=display:flex><span>        container.ComposeExportedValue&lt;IPipeline&gt;(pipeline);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// resolve the root type - a simple http server</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> server = container.GetExportedValue&lt;Server&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// start the server</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> service = server.Start(<span style=color:#e6db74>@&#34;http://127.0.0.1:8080/&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// keep accepting connections</span>
</span></span><span style=display:flex><span>        service.Wait();
</span></span><span style=display:flex><span>    } <span style=color:#75715e>// dispose</span>
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>First notice that I am using the <a href=http://mef.codeplex.com/>Managed Extensibility Framework</a> as my <a href=http://en.wikipedia.org/wiki/Dependency_injection>DI container</a>. Any other <a href=http://www.hanselman.com/blog/ListOfNETDependencyInjectionContainersIOC.aspx>DI container</a> would work in this case, but MEF allowed me to stick with the .NET framework and also didn&rsquo;t need any additional configuration to work - which was nice for this simple example. So the first thing to notice is that we have an interface for our Pipeline which we are preparing externally from the actual service. In this case we are saying that the pipeline will consist of Logging and a FakeResponse - and injecting that to our server. Our server then will execute the pipeline following the chain. It&rsquo;s easy to see how we can externalize this configuration to a config file allowing us to modify the behavior of the service without necessarily making a code change. We will talk more about this just a little later, for now let&rsquo;s look at how the server is configured:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[Export]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Server</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IHttpListener listener;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>readonly</span> IPipeline pipeline;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>    [ImportingConstructor]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> Server(IHttpListener listener, IPipeline pipeline)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.listener = listener;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.pipeline = pipeline;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>async</span> Task Start(<span style=color:#66d9ef>string</span> address)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.listener.Prefixes.Add(address);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.listener.Start();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// keep listening</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// wait for a listener</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> context = <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>this</span>.listener.GetContextAsync().ConfigureAwait(<span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// initiate the pipeline and forget</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.pipeline.Continue(context);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>This is probably one of the most simplest HTTP servers. It accepts a requests and passes it forward to the first item in the pipeline. That&rsquo;s it. Recall, the pipeline was built external to the server and injected to it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[InheritedExport]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>IPipeline</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> Continue(HttpListenerContext listenerContext);
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>The execution pipeline interface is extremely simple. It accepts a Continuation to the next execution pipeline. One of things you want to do when you build interfaces is to think of the minimal set that satifies what you are trying to do. The leaner your interfaces, the less likely they will change, and therefore have less impact on the overall system. The recommendaton for most interfaces is to have no more than 3-4 methods. The .NET Framework interfaces not surprisingly has 3.75 members, with a methods-to-properties ratio of 3.5:1. If your interfaces start to have more than 10 methods, you&rsquo;re probably building more than one responsiblity in an interface and there&rsquo;s probably an opportunity to separate them. This task is often referred to as decomposition. Now that we have the base interface we need to build an abstract concept that allows to move to the next item in the pipeline. Because interface does not define that, the interface just says you should be able to continue. For that we create an abstract BaseContinuationPipeline.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BaseContinuationPipeline</span> : IPipeline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> IPipeline forward;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> BaseContinuationPipeline()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// default is the terminating pipeline</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.forward = <span style=color:#66d9ef>new</span> TerminatingPipeline(); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> BaseContinuationPipeline(IPipeline forward)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.forward = forward;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> Continue(HttpListenerContext listenerContext)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Task.Run(() =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// execute the &#34;abstract&#34; action</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.Execute(listenerContext);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// continue to the next action</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>this</span>.forward.Continue(listenerContext);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> Execute(HttpListenerContext listenerContext);
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>There are few things to point out here: the first thing is the default forward continuation to the pipeline is this special item in the pipeline called a terminating pipeline. It&rsquo;s sole purpose is to end the request. This pattern of using a special object to handle empty set is referred to as the <a href=http://en.wikipedia.org/wiki/Null_Object_pattern>Null Object Pattern</a>. There were several ways to implement this special case. For instance, I could have simply left the forward object to null, and if it was null - prevent the forwarding and end the request. However, the problem with this is you are implementing a special case while your normal control flow of your logic can support it. The second thing is there might be other parts of the pipeline where I may decide to end the request, in which case I only need to forward it to the terminating pipeline (no repeating logic). One good sign of a well designed software is it&rsquo;s overall lack of conditional statements. If you think about it conditional statements (if/else, switch) are sort of a forced behavior to your normal control flow. Now I am not saying remove all conditional statements, that would be absurd there is no way to check if 5 > 3 without actually doing a if statement but for business objects you should think twice if you are constantly checking if the object is null. Also notice that the default is the terminating pipeline. This means even if the caller does not pass any feature sets to the pipeline the default behavior will be stop the execution. You always want to do a safe design, meaning that your APIs are full proof such that no matter how you interact with it the baseline behavior is at least functional. So let&rsquo;s keep moving forward. This abstract class does not know about any features so it simply describes how to move forward to the next continuation and keeps the execution abstract. The current item in the pipeline is executed by doing this.Execute, and then the request is forwarded to the next responsible party. That&rsquo;s it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TerminatingPipeline</span> : IPipeline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Continue(HttpListenerContext listenerContext)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// end the response stream</span>
</span></span><span style=display:flex><span>        listenerContext.Response.Close();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// no more forwarding</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>So like we talked about before the terminating pipeline implements IPipeline interface and it&rsquo;s continuation is to simply to end the request and there&rsquo;s no where to forward to since this is always going to be the last item in the list. And to close, let&rsquo;s look at the two items in our pipeline, the logging and the fakeresponse:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggingPipeline</span> : BaseContinuationPipeline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> LoggingPipeline(IPipeline forward) : <span style=color:#66d9ef>base</span>(forward) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(HttpListenerContext listenerContext)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Console.WriteLine(listenerContext.Request.Url);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FakeResponsePipeline</span> : BaseContinuationPipeline
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> Execute(HttpListenerContext listenerContext)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>string</span> response = <span style=color:#e6db74>&#34;hello world&#34;</span>;
</span></span><span style=display:flex><span>        listenerContext.Response.OutputStream.WriteAsync(ASCIIEncoding.ASCII.GetBytes(response), <span style=color:#ae81ff>0</span>, response.Length);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>They both implement the BaseContinuationPipeline because they both support continuations. In fact, all our pipeline elements will implement continuations except the special TerminatingPipeline. The logging pipeline simply prints the incoming URL, and the FakeResponse writes Hello World to the output. With that we have a foundation to build something on top of. I will continue this discussion with more functionality with support for hierarchies, non-sequential and state-ful pipelines. All of which will be required to build a fully functional service.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.salmanq.com/tags/uncategorized/>Uncategorized</a></li></ul><nav class=paginav><a class=prev href=https://www.salmanq.com/blog/5-things-you-probably-didnt-know-about-net-websockets/><span class=title>« Prev</span><br><span>5 things you probably didn't know about .NET WebSockets</span></a>
<a class=next href=https://www.salmanq.com/blog/self-awareness/><span class=title>Next »</span><br><span>Self-Awareness</span></a></nav></footer><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-dark crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.salmanq.com/>Salman Quazi</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>