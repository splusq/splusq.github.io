<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.120.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Task Timeouts &#183; Salman Quazi</title>
<meta name=description content><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/poole.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/syntax.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><style type=text/css>.sidebar-about h1{font-size:1.95rem;font-weight:400}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-K4WVH5P91F"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K4WVH5P91F")</script></head><body class=theme-base-08><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://www.salmanq.com/><h1>Salman Quazi</h1></a><p class=lead>Engineering Manager for Microsoft Azure Cognitive Services in Mountain View, CA.</p></div><nav><ul class=sidebar-nav><li><a href=https://www.salmanq.com/>Home</a></li><li><a href=/blog/>Blog</a></li><li><a href=https://github.com/splusq/>Github</a></li><li><a href=https://www.linkedin.com/in/salmanquazi/>LinkedIn</a></li><li><a href=https://www.twitter.com/splusq>Twitter</a></li></ul></nav><p>Opinions are my own.</p></div></aside><main class="content container"><div class=post><h1>Task Timeouts</h1><time datetime=2013-02-26T03:25:30Z class=post-date>Tue, Feb 26, 2013</time><p>When dealing with .NET tasks – we often want to timeout the operation if it does not complete within a certain period of time. For instance, if you make an asynchronous WebRequest call – you may want to timeout this asynchronous operation within 3 seconds if you don’t get a response back. In the past, we had to create Timers to monitor the Task (or the Thread) for completion in the callback of the timer, and then do other crazy gymnastics to make it all play well together. However, the result was a code that was extremely difficult to understand because you had these disparate methods, without any cohesiveness within the code. With .NET 4.5 we can simplify this dramatically.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>async</span> Task&lt;T&gt; TimeoutAfter&lt;T&gt;(<span style=color:#66d9ef>this</span> Task&lt;T&gt; task, <span style=color:#66d9ef>int</span> delay)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>await</span> Task.WhenAny(task, Task.Delay(delay));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (!task.IsCompleted)
</span></span><span style=display:flex><span>	{
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> TimeoutException();	
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>await</span> task;
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>The idea is to use the WhenAny method, which creates a Task that completes when either one of the task completes. In this case, we pass in the Task that we want to monitor (task) and we pass a Task.Delay task which is yet another task that completes after a specified amount of milliseconds. So either the Task.Delay will complete or our task will complete. Simple, and elegant. And the best part is this is just an extension method so you can use it anywhere! You can even compose them into a chain of other extension methods.</p></div><h2>Comments</h2><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></main></body></html>