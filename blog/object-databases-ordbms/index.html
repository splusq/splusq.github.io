<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.134.2"><meta name=viewport content="width=device-width,initial-scale=1"><title>Object Databases (ORDBMS) &#183; Salman Quazi</title>
<meta name=description content><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/poole.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/syntax.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><style type=text/css>.sidebar-about h1{font-size:1.95rem;font-weight:400}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-K4WVH5P91F"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K4WVH5P91F")</script></head><body class=theme-base-08><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://www.salmanq.com/><h1>Salman Quazi</h1></a><p class=lead>Director of Engineering for Microsoft Azure OpenAI in Mountain View, CA.</p></div><nav><ul class=sidebar-nav><li><a href=https://www.salmanq.com/>Home</a></li><li><a href=/blog/>Blog</a></li><li><a href=https://github.com/splusq/>Github</a></li><li><a href=https://www.linkedin.com/in/salmanquazi/>LinkedIn</a></li><li><a href=https://www.twitter.com/splusq>Twitter</a></li></ul></nav><p>Opinions are my own.</p></div></aside><main class="content container"><div class=post><h1>Object Databases (ORDBMS)</h1><time datetime=2004-11-10T19:38:02Z class=post-date>Wed, Nov 10, 2004</time><p>ORDBMS - Object Relational, Database Management system. Is an object oriented database management system. The concept at first is a bit suprising since relational database sort of by definition negates the concept of objects. In theory a relational database is a set of relation R; each table, formally known as relations, can be joined (cartesian product) to produce a new relation (which is an improper subset of R1xR2). There are many problems with this scenario. Lets say you want a database that contains sets of points where computers are physically located in a global positioning system. This hypothetical organization contains various departments, a set of departments makes up a local-organization, and a set of local-organization makes up an organization, to make situations worst, each continent can contain several organizations; and there are seven continents. This company is so large they have branches all over the seven continents. The point of this all is to find the minimal net-cost (where cost is distance) for communication between computers. Your product is expected to answers queries of this type:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>what is the most optimal link between
</span></span><span style=display:flex><span>continent <span style=color:#ae81ff>1</span> - organization <span style=color:#ae81ff>2</span> - local-organization <span style=color:#ae81ff>3</span> - department <span style=color:#ae81ff>0</span> and
</span></span><span style=display:flex><span>continent <span style=color:#ae81ff>4</span> - organization <span style=color:#ae81ff>3</span> - local-organization <span style=color:#ae81ff>0</span> - department <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>... 
</span></span></code></pre></div><p>How would one go about storing this information in a relational database (while maintaining all the database-normalization factors?). NF-1 says your information has to be atomic; which means each field cannot contain more than one information. For instance, according to NF-1 it would be illegal to have something like this: (John, Doe). Because that field contains two information one: John (which is the first name) and Doe (which is the last name). Transitively it can implied that storing information like (x1,y1,z1) would be incorrect according to NF-1 since it contains more than one information.</p><p>Well we can take care of that. Maybe we will have three columns. One for the X values, another for the Y values and yet another Z values. That&rsquo;s sounds good. But now, how do we know which sets of points correspond to which computer?</p><p>As I noted earlier you need a database that can contain a set of points not just a single point. Once again this is what you need: N = { (x1,y1,z1), (x2,y2,z3), &mldr; , (Xn,Yn,Zn) }. Notice that x1,y1,z1, x2,y2,z2 and Xn,Yn,Zn all correspond to the network N. If we store the data as suggested above then we loose the information which points correspond to which network. Because as far as the specification goes there can be infinetly many networks. Well you say you can take care of that as well. You add a fourth column that will tell you which network the points belong to.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>N	X	Y
</span></span><span style=display:flex><span>1	10	<span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>1	11.4	-100
</span></span><span style=display:flex><span>2	2.2	<span style=color:#ae81ff>90</span>
</span></span><span style=display:flex><span>2	..	..
</span></span><span style=display:flex><span>2	..	.. 
</span></span></code></pre></div><p>So far so good. Now you can do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>select</span> CONCAT(CONCAT(CONCAT(CONCAT(<span style=color:#e6db74>&#34;(&#34;</span>,R.x1),<span style=color:#e6db74>&#34;,&#34;</span>),R.y1),<span style=color:#e6db74>&#34;)&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>from</span> R <span style=color:#66d9ef>where</span> N <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; 
</span></span></code></pre></div><p>&mldr; and you have all the points that belong to N(1). Since each department can contain several networks you decide to make another table D which will contain the following information:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span> Department	N
</span></span><span style=display:flex><span>  3215		<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  3025		<span style=color:#ae81ff>2</span> 
</span></span></code></pre></div><p>Good so far. Now you have taken care of yet another level. But there are so many levels, local-organization, organization, continent! Each of which will require you to add at least one more column and worst of all, you will have to manually bend the relational database model to work for you. The point of it all is it gets exponentially complicated to keep track of what&rsquo;s going on after a certain point &ndash; and this is a good point to assume we are reaching the limitation of relational database.</p><p><strong><em>Note:</em></strong> This is just for illustration purposes. Finding minimal-cost between nodes of computers is a typical graph problem &ndash; and database is a completely inappropriate storage medium.</p><p><strong>Object-Oriented Database</strong></p><p>This is where object-oriented databases come in. Before I go into the details of why an object-oriented database is useful let me just differentiate between an object-oriented database and an object-relational database. Object-Oriented database is a database management system that can store objects. That means you can say a table R can contain an object of type C. A object-relational database on the other hand is still a typical relational database, but another layer is added beyond the relational optimizer layer which converts relational queries and outputs to object-based queries and object-based storage respectively. Notice the crucial difference between object-oriented database and object-relational database. Object oriented database are much much faster because the underlying DBMS understands and recognizes objects where as a object-relational database just simulates this process.</p><p>Last year I was working on a project called: Object-Relational DBMS. It&rsquo;s another layer written on-top of MySQL optimizer to view relations as objects. A solution for the above problem can be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span> Object <span style=color:#a6e22e>point</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>x</span> <span style=color:#66d9ef>float</span>,
</span></span><span style=display:flex><span> <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>float</span>,
</span></span><span style=display:flex><span> <span style=color:#a6e22e>z</span> <span style=color:#66d9ef>float</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object <span style=color:#a6e22e>computer</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>pt</span> <span style=color:#a6e22e>point</span>,
</span></span><span style=display:flex><span> <span style=color:#a6e22e>network</span> <span style=color:#a6e22e>integer</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object <span style=color:#a6e22e>department</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>network</span> <span style=color:#a6e22e>computer</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object <span style=color:#a6e22e>local</span><span style=color:#f92672>-</span><span style=color:#a6e22e>organization</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>depts</span> <span style=color:#a6e22e>department</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object <span style=color:#a6e22e>organization</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>lg</span> <span style=color:#a6e22e>local</span><span style=color:#f92672>-</span><span style=color:#a6e22e>organization</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object <span style=color:#a6e22e>continent</span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>org</span> <span style=color:#a6e22e>organization</span>; 
</span></span></code></pre></div><p>Notice how in the object computer, you are able to use point as a datatype (which itself was an object). Although internally these are stored as relations, from the programmers&rsquo; perspective it&rsquo;s not at all the case. Everything becomes much simpler to conceive.</p></div><h2>Comments</h2><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></main></body></html>