<!doctype html><html xmlns=http://www.w3.org/1999/xhtml xml:lang=en-us lang=en-us><head><link href=https://gmpg.org/xfn/11 rel=profile><meta charset=utf-8><meta name=generator content="Hugo 0.134.2"><meta name=viewport content="width=device-width,initial-scale=1"><title>5 things you probably didn't know about .NET WebSockets &#183; Salman Quazi</title>
<meta name=description content><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/print.css media=print><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/poole.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/syntax.css><link type=text/css rel=stylesheet href=https://www.salmanq.com/css/hyde.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700"><link rel=apple-touch-icon-precomposed sizes=144x144 href=/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/favicon.png><style type=text/css>.sidebar-about h1{font-size:1.95rem;font-weight:400}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-K4WVH5P91F"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-K4WVH5P91F")</script></head><body class=theme-base-08><aside class=sidebar><div class="container sidebar-sticky"><div class=sidebar-about><a href=https://www.salmanq.com/><h1>Salman Quazi</h1></a><p class=lead>Director of Engineering for Microsoft Azure OpenAI in Mountain View, CA.</p></div><nav><ul class=sidebar-nav><li><a href=https://www.salmanq.com/>Home</a></li><li><a href=/blog/>Blog</a></li><li><a href=https://github.com/splusq/>Github</a></li><li><a href=https://www.linkedin.com/in/salmanquazi/>LinkedIn</a></li><li><a href=https://www.twitter.com/splusq>Twitter</a></li></ul></nav><p>Opinions are my own.</p></div></aside><main class="content container"><div class=post><h1>5 things you probably didn't know about .NET WebSockets</h1><time datetime=2013-04-13T23:45:28Z class=post-date>Sat, Apr 13, 2013</time><p><img src=/2013/04/websockets.png alt=WebSockets> As most of you probably already know WebSocket provides full-duplex communication over a single TCP connection. .NET 4.5 added support for WebSockets as part of the BCL. In this article I am going to talk about few of the subtleties that you need to think about.</p><ol><li><p><strong>Connection upgrade is somewhat expensive</strong> WebSocket connections are initiated as traditional HTTP connections. The client then usually requests an &ldquo;upgrade&rdquo; to a WebSocket session, this upgrade process is relatively expensive. If you are interested in performance you may want to pool a set of connection that are already upgraded and use connections from the pool.</p></li><li><p><strong>Simultaneous sends or receives</strong> While you can simultaneously do send and receive, you can only do one of each simultaneously. In other words at any given point in time you can only have a single pending send or a single pending receive. Various workaround exists for this limitation. For instance, <a href=https://github.com/SignalR/SignalR/blob/master/src/Microsoft.AspNet.SignalR.Owin45/WebSockets/WebSocketHandler.cs>SignalR</a> uses a queue. The other option is to provide synchronizations using a ManualResetEvent - there are pros and cons to both so you need to think about what makes sense for your specific application.</p></li><li><p><strong>Teardown</strong> There are two ways to close a WebSocket connection. The graceful way is <a href=http://msdn.microsoft.com/en-us/library/system.net.websockets.websocket.closeasync.aspx>CloseAsync</a> which when initiated <strong>sends a message</strong> to the connected party, and waits for acknowledgement. The keyword here is <em>sends</em>. Remember in our previous point we discussed that you can only have a single send or receive at any given point in time? So if you are sending data, and at the same time try to CloseAsync this leads to an exception because CloseAsync will <em>also</em> try to send a message. The other option is to use <a href=http://msdn.microsoft.com/en-us/library/system.net.websockets.websocket.closeoutputasync.aspx>CloseOutputAsync</a> this is more of a &ldquo;fire-and-forget&rdquo; approach.</p></li><li><p><strong>COM Exceptions?</strong> Based on some of our testing there are certain COM level exceptions that can happen during high load conditions. Once again if you look at the <a href=https://github.com/SignalR/SignalR/blob/master/src/Microsoft.AspNet.SignalR.Owin45/WebSockets/WebSocketHandler.cs>SignalR implementation</a> you can treat these types of exceptions as non-fatal. 0x800703e3 - The I/O operation has been aborted because of either a thread exit or application request 0x800704cd - The remote host closed the connection 0x80070026 - Reached the end-of-file</p></li><li><p><strong>Unobserved Exceptions</strong> Any unobserved exceptions (background thread exceptions that weren&rsquo;t caught) can cause your WebSocket to get into an aborted state. This is because the .NET 4.5 implementation of WebSocket adds a <a href=http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskscheduler.unobservedtaskexception.aspx>TaskScheulder.UnobservedExceptions</a> handler and aborts the connection for any exceptions that propagate up to it. So you have couple of choices here, first make sure that you don&rsquo;t have unobserved exceptions (which means you have an issue that you are not even aware of). If you call any method that initiates a Task - make sure you store it and add a continuation to observe it&rsquo;s exceptions. The other option is to add a TaskScheduler.UnobservedExceptions yourself to see what potential exceptions you are missing.</p></li></ol></div><h2>Comments</h2><script src=https://utteranc.es/client.js repo=splusq/splusq.github.io issue-term=title theme=github-light crossorigin=anonymous async></script></main></body></html>